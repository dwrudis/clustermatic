$Id: bproc-patch-2.6.9,v 1.2 2004/10/27 20:46:29 mkdist Exp $

NOTE:  This patch is against stock kernels from kernel.org, not
vendor kernels such as those from Red Hat or SuSE.  This patch
will not apply cleanly against those.

diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/entry.S linux-2.6.9/arch/i386/kernel/entry.S
--- linux-2.6.9-clean/arch/i386/kernel/entry.S	2004-10-18 15:53:44.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/entry.S	2004-10-27 13:58:35.000000000 -0600
@@ -286,7 +286,8 @@
 syscall_call:
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)		# store the return value
-syscall_exit:
+
+ENTRY(syscall_exit)
 	cli				# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
@@ -633,7 +634,7 @@
 	.long sys_mknod
 	.long sys_chmod		/* 15 */
 	.long sys_lchown16
-	.long sys_ni_syscall	/* old break syscall holder */
+	.long i386_bproc	/* old break syscall holder */
 	.long sys_stat
 	.long sys_lseek
 	.long sys_getpid	/* 20 */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/i386_ksyms.c linux-2.6.9/arch/i386/kernel/i386_ksyms.c
--- linux-2.6.9-clean/arch/i386/kernel/i386_ksyms.c	2004-10-18 15:55:29.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/i386_ksyms.c	2004-10-27 13:58:35.000000000 -0600
@@ -197,3 +197,6 @@
 #endif
 
 EXPORT_SYMBOL(csum_partial);
+
+asmlinkage void syscall_exit(void) __asm__("syscall_exit");
+EXPORT_SYMBOL_NOVERS(syscall_exit);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/ldt.c linux-2.6.9/arch/i386/kernel/ldt.c
--- linux-2.6.9-clean/arch/i386/kernel/ldt.c	2004-10-18 15:54:39.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/ldt.c	2004-10-27 13:58:35.000000000 -0600
@@ -13,6 +13,7 @@
 #include <linux/smp_lock.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -104,6 +105,7 @@
 	}
 	return retval;
 }
+EXPORT_SYMBOL_GPL(init_new_context);
 
 /*
  * No need to lock the MM as we are the last user
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/process.c linux-2.6.9/arch/i386/kernel/process.c
--- linux-2.6.9-clean/arch/i386/kernel/process.c	2004-10-18 15:53:05.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/process.c	2004-10-27 13:58:35.000000000 -0600
@@ -36,6 +36,7 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 #include <linux/ptrace.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -275,6 +276,10 @@
 {
 	struct pt_regs regs;
 
+	/* BProc: (SLAVE) kernel forks are not subject to BProc's
+	 * remote process management stuff. */
+	bproc_kcall();
+
 	memset(&regs, 0, sizeof(regs));
 
 	regs.ebx = (unsigned long) fn;
@@ -662,6 +667,10 @@
 	}
 	putname(filename);
 out:
+	if (error == -ENOENT)
+		error = bproc_hook_imv(error, sys_execve,
+				       (&regs,(char *)regs.ebx,
+					(char **)regs.ecx, (char **)regs.edx));
 	return error;
 }
 
@@ -804,3 +813,6 @@
 	return 0;
 }
 
+asmlinkage long i386_bproc(struct pt_regs regs) {
+        return sys_bproc(regs.ebx, regs.ecx, regs.edx, &regs);
+}
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/ptrace.c linux-2.6.9/arch/i386/kernel/ptrace.c
--- linux-2.6.9-clean/arch/i386/kernel/ptrace.c	2004-10-18 15:53:45.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/ptrace.c	2004-10-27 13:58:35.000000000 -0600
@@ -15,6 +15,8 @@
 #include <linux/user.h>
 #include <linux/security.h>
 #include <linux/audit.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -249,17 +251,20 @@
 			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
+		bproc_hook_im(ptrace_traceme,());
 		ret = 0;
 		goto out;
 	}
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child = bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		goto out;
+	}
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
@@ -274,6 +279,11 @@
 	if (ret < 0)
 		goto out_tsk;
 
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		goto out_tsk;
+	}
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */ 
@@ -523,6 +533,7 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL_GPL(sys_ptrace);
 
 /* notification of system call entry/exit
  * - triggered by current->work.syscall_trace
@@ -559,3 +570,4 @@
 		current->exit_code = 0;
 	}
 }
+EXPORT_SYMBOL_GPL(do_syscall_trace);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/smp.c linux-2.6.9/arch/i386/kernel/smp.c
--- linux-2.6.9-clean/arch/i386/kernel/smp.c	2004-10-18 15:53:12.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/smp.c	2004-10-27 13:58:35.000000000 -0600
@@ -10,6 +10,7 @@
 
 #include <linux/init.h>
 
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/irq.h>
 #include <linux/delay.h>
@@ -104,6 +105,7 @@
  */
 
 DEFINE_PER_CPU(struct tlb_state, cpu_tlbstate) ____cacheline_aligned = { &init_mm, 0, };
+EXPORT_SYMBOL_GPL(per_cpu__cpu_tlbstate);
 
 /*
  * the following functions deal with sending IPIs between CPUs.
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/traps.c linux-2.6.9/arch/i386/kernel/traps.c
--- linux-2.6.9-clean/arch/i386/kernel/traps.c	2004-10-18 15:53:23.000000000 -0600
+++ linux-2.6.9/arch/i386/kernel/traps.c	2004-10-27 13:58:35.000000000 -0600
@@ -62,6 +62,7 @@
 
 struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
 		{ 0, 0 }, { 0, 0 } };
+EXPORT_SYMBOL_GPL(default_ldt);
 
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq = 0;
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/kernel/vsyscall.lds linux-2.6.9/arch/i386/kernel/vsyscall.lds
--- linux-2.6.9-clean/arch/i386/kernel/vsyscall.lds	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.9/arch/i386/kernel/vsyscall.lds	2004-10-27 13:58:35.000000000 -0600
@@ -0,0 +1,72 @@
+/*
+ * Linker script for vsyscall DSO.  The vsyscall page is an ELF shared
+ * object prelinked to its virtual address, and with only one read-only
+ * segment (that fits in one page).  This script controls its layout.
+ */
+
+
+
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by arch/i386/Makefile
+ *
+ */
+SECTIONS
+{
+  . = -8192 + SIZEOF_HEADERS;
+
+  .hash : { *(.hash) } :text
+  .dynsym : { *(.dynsym) }
+  .dynstr : { *(.dynstr) }
+  .gnu.version : { *(.gnu.version) }
+  .gnu.version_d : { *(.gnu.version_d) }
+  .gnu.version_r : { *(.gnu.version_r) }
+
+  /* This linker script is used both with -r and with -shared.
+     For the layouts to match, we need to skip more than enough
+     space for the dynamic symbol table et al.  If this amount
+     is insufficient, ld -shared will barf.  Just increase it here.  */
+  . = -8192 + 0x400;
+
+  .text : { *(.text) } :text =0x90909090
+
+  .eh_frame_hdr : { *(.eh_frame_hdr) } :text :eh_frame_hdr
+  .eh_frame : { KEEP (*(.eh_frame)) } :text
+  .dynamic : { *(.dynamic) } :text :dynamic
+  .useless : {
+        *(.got.plt) *(.got)
+        *(.data .data.* .gnu.linkonce.d.*)
+        *(.dynbss)
+        *(.bss .bss.* .gnu.linkonce.b.*)
+  } :text
+}
+
+/*
+ * We must supply the ELF program headers explicitly to get just one
+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.
+ */
+PHDRS
+{
+  text PT_LOAD FILEHDR PHDRS FLAGS(5); /* PF_R|PF_X */
+  dynamic PT_DYNAMIC FLAGS(4); /* PF_R */
+  eh_frame_hdr 0x6474e550; /* PT_GNU_EH_FRAME, but ld doesn't match the name */
+}
+
+/*
+ * This controls what symbols we export from the DSO.
+ */
+VERSION
+{
+  LINUX_2.5 {
+    global:
+        __kernel_vsyscall;
+        __kernel_sigreturn;
+        __kernel_rt_sigreturn;
+
+    local: *;
+  };
+}
+
+/* The ELF entry point can be used to set the AT_SYSINFO value.  */
+ENTRY(__kernel_vsyscall);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/i386/mm/mmap.c linux-2.6.9/arch/i386/mm/mmap.c
--- linux-2.6.9-clean/arch/i386/mm/mmap.c	2004-10-18 15:54:07.000000000 -0600
+++ linux-2.6.9/arch/i386/mm/mmap.c	2004-10-27 13:58:35.000000000 -0600
@@ -26,6 +26,7 @@
 
 #include <linux/personality.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 
 /*
  * Top of mmap area (just below the process stack).
@@ -69,3 +70,4 @@
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
 }
+EXPORT_SYMBOL_GPL(arch_pick_mmap_layout);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/kernel/entry.S linux-2.6.9/arch/ppc/kernel/entry.S
--- linux-2.6.9-clean/arch/ppc/kernel/entry.S	2004-10-18 15:55:06.000000000 -0600
+++ linux-2.6.9/arch/ppc/kernel/entry.S	2004-10-27 13:58:35.000000000 -0600
@@ -443,6 +443,21 @@
 	stw	r0,TRAP(r1)		/* register set saved */
 	b	sys_clone
 
+	/* BProc: We need to save all regs on the way in AND restore
+	 * on the way out.  Also, we setup arguments.  r3,r4,r5 are
+	 * fine where they are.  We stick a pointer to our regs in the
+	 * 4th arg (r6). */
+	.globl	ppc_bproc
+ppc_bproc:
+	SAVE_NVGPRS(r1)
+	lwz	r0,TRAP(r1)
+	rlwinm	r0,r0,0,0,30		/* clear LSB to indicate full */
+	stw	r0,TRAP(r1)		/* register set saved */
+	addi	6,1,STACK_FRAME_OVERHEAD
+	bl	sys_bproc
+	REST_NVGPRS(r1)
+	b	ret_from_syscall
+
 	.globl	ppc_swapcontext
 ppc_swapcontext:
 	SAVE_NVGPRS(r1)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/kernel/misc.S linux-2.6.9/arch/ppc/kernel/misc.S
--- linux-2.6.9-clean/arch/ppc/kernel/misc.S	2004-10-18 15:55:07.000000000 -0600
+++ linux-2.6.9/arch/ppc/kernel/misc.S	2004-10-27 13:58:35.000000000 -0600
@@ -1132,6 +1132,15 @@
  */
 _GLOBAL(kernel_thread)
 	stwu	r1,-16(r1)
+
+	/* BProc: This gets called from kernel space so flag this
+	 * entry into clone as a kernel call. */
+	mflr	r0		/* Save return address (LR) */
+	stw	r0,20(r1)
+	bl	__bproc_kcall
+	lwz	r0,20(r1)	/* Retore LR */
+	mtlr	r0
+
 	stw	r30,8(r1)
 	stw	r31,12(r1)
 	mr	r30,r3		/* function */
@@ -1195,7 +1204,7 @@
 	.long sys_mknod
 	.long sys_chmod		/* 15 */
 	.long sys_lchown
-	.long sys_ni_syscall			/* old break syscall holder */
+	.long ppc_bproc				/* old break syscall holder */
 	.long sys_stat
 	.long sys_lseek
 	.long sys_getpid	/* 20 */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/kernel/ppc_ksyms.c linux-2.6.9/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.6.9-clean/arch/ppc/kernel/ppc_ksyms.c	2004-10-18 15:55:07.000000000 -0600
+++ linux-2.6.9/arch/ppc/kernel/ppc_ksyms.c	2004-10-27 13:58:35.000000000 -0600
@@ -356,3 +356,6 @@
 EXPORT_SYMBOL(__mtdcr);
 EXPORT_SYMBOL(__mfdcr);
 #endif
+
+asmlinkage void ret_from_syscall(void);
+EXPORT_SYMBOL_NOVERS(ret_from_syscall);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/kernel/process.c linux-2.6.9/arch/ppc/kernel/process.c
--- linux-2.6.9-clean/arch/ppc/kernel/process.c	2004-10-18 15:54:08.000000000 -0600
+++ linux-2.6.9/arch/ppc/kernel/process.c	2004-10-27 13:58:35.000000000 -0600
@@ -37,6 +37,7 @@
 #include <linux/kallsyms.h>
 #include <linux/mqueue.h>
 #include <linux/hardirq.h>
+#include <linux/bproc.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -602,6 +603,10 @@
 		current->ptrace &= ~PT_DTRACE;
 	putname(filename);
 out:
+	if (error == -ENOENT)
+		error = bproc_hook_imv(error, sys_execve,
+				       (regs, (char *)a0,
+					(char **)a1, (char **)a2));
 	return error;
 }
 
@@ -777,3 +782,7 @@
 	} while (count++ < 16);
 	return 0;
 }
+
+void __bproc_kcall(void) {
+        bproc_kcall();
+}
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/kernel/ptrace.c linux-2.6.9/arch/ppc/kernel/ptrace.c
--- linux-2.6.9-clean/arch/ppc/kernel/ptrace.c	2004-10-18 15:53:44.000000000 -0600
+++ linux-2.6.9/arch/ppc/kernel/ptrace.c	2004-10-27 13:58:35.000000000 -0600
@@ -26,6 +26,8 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -250,17 +252,20 @@
 			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
+		bproc_hook_im(ptrace_traceme,());
 		ret = 0;
 		goto out;
 	}
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child = bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		goto out;
+	}
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
@@ -275,6 +280,11 @@
 	if (ret < 0)
 		goto out_tsk;
 
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		goto out_tsk;
+	}
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
@@ -452,6 +462,7 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL_GPL(sys_ptrace);
 
 void do_syscall_trace(void)
 {
@@ -471,3 +482,4 @@
 		current->exit_code = 0;
 	}
 }
+EXPORT_SYMBOL_GPL(do_syscall_trace);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc/mm/mmu_context.c linux-2.6.9/arch/ppc/mm/mmu_context.c
--- linux-2.6.9-clean/arch/ppc/mm/mmu_context.c	2004-10-18 15:54:31.000000000 -0600
+++ linux-2.6.9/arch/ppc/mm/mmu_context.c	2004-10-27 13:58:35.000000000 -0600
@@ -26,12 +26,14 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/module.h>
 
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
 
 mm_context_t next_mmu_context;
 unsigned long context_map[LAST_CONTEXT / BITS_PER_LONG + 1];
+EXPORT_SYMBOL_GPL(context_map);
 #ifdef FEW_CONTEXTS
 atomic_t nr_free_contexts;
 struct mm_struct *context_mm[LAST_CONTEXT+1];
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/entry.S linux-2.6.9/arch/ppc64/kernel/entry.S
--- linux-2.6.9-clean/arch/ppc64/kernel/entry.S	2004-10-18 15:53:06.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/entry.S	2004-10-27 13:58:35.000000000 -0600
@@ -146,6 +146,10 @@
 	mtctr   r10
 	bctrl			/* Call handler */
 
+	/* BProc: can't just make syscall_exit a global because other
+	 * asm code will end up pointing at the function descriptor.
+	 * Instead add an additional symbol at this address. */
+_GLOBAL(ret_from_sys_call)
 syscall_exit:
 #ifdef SHOW_SYSCALLS
 	std	r3,GPR3(r1)
@@ -302,6 +306,17 @@
 	bl	.sys_swapcontext
 	b	80f
 
+	/* BProc: We need to save all regs on the way in AND restore
+	 * on the way out.  Also, we setup arguments.  r3,r4,r5 are
+	 * fine where they are.  We stick a pointer to our regs in the
+	 * 4th arg (r6). */
+_GLOBAL(ppc_bproc)
+	bl	.save_nvgprs
+	addi	6,1,STACK_FRAME_OVERHEAD
+	bl	.sys_bproc
+	REST_NVGPRS(r1)
+	b	syscall_exit
+
 _GLOBAL(ppc32_sigreturn)
 	bl	.sys32_sigreturn
 	b	80f
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/misc.S linux-2.6.9/arch/ppc64/kernel/misc.S
--- linux-2.6.9-clean/arch/ppc64/kernel/misc.S	2004-10-18 15:55:06.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/misc.S	2004-10-27 13:58:35.000000000 -0600
@@ -665,6 +665,15 @@
 	stdu	r1,-STACK_FRAME_OVERHEAD(r1)
 	mr	r29,r3
 	mr	r30,r4
+	
+	/* BProc: This gets called from kernel space so flag this
+	 * entry into clone as a kernel call. */
+	mflr	r0
+ 	std	r0, STACK_FRAME_OVERHEAD-32(r1)
+ 	bl	.__bproc_kcall
+ 	ld	r0, STACK_FRAME_OVERHEAD-32(r1)
+ 	mtlr	r0
+	
 	ori	r3,r5,CLONE_VM	/* flags */
 	oris	r3,r3,(CLONE_UNTRACED>>16)
 	li	r4,0		/* new sp (unused) */
@@ -711,7 +720,7 @@
 	.llong .sys_mknod
 	.llong .sys_chmod		/* 15 */
 	.llong .sys_lchown
-	.llong .sys_ni_syscall		/* old break syscall */
+	.llong .ppc_bproc		/* old break syscall */
 	.llong .sys_ni_syscall		/* old stat syscall */
 	.llong .ppc32_lseek
 	.llong .sys_getpid              /* 20 */
@@ -983,7 +992,7 @@
 	.llong .sys_mknod
 	.llong .sys_chmod		/* 15 */
 	.llong .sys_lchown
-	.llong .sys_ni_syscall		/* old break syscall */
+	.llong .ppc_bproc		/* old break syscall */
 	.llong .sys_ni_syscall		/* old stat syscall */
 	.llong .sys_lseek
 	.llong .sys_getpid		/* 20 */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/ppc_ksyms.c linux-2.6.9/arch/ppc64/kernel/ppc_ksyms.c
--- linux-2.6.9-clean/arch/ppc64/kernel/ppc_ksyms.c	2004-10-18 15:53:43.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/ppc_ksyms.c	2004-10-27 13:58:35.000000000 -0600
@@ -123,7 +123,7 @@
 #ifdef CONFIG_ALTIVEC
 EXPORT_SYMBOL(giveup_altivec);
 #endif
-EXPORT_SYMBOL(flush_icache_range);
+EXPORT_SYMBOL(__flush_icache_range);
 EXPORT_SYMBOL(flush_icache_user_range);
 EXPORT_SYMBOL(flush_dcache_page);
 #ifdef CONFIG_SMP
@@ -163,3 +163,6 @@
 EXPORT_SYMBOL(paca);
 EXPORT_SYMBOL(cur_cpu_spec);
 EXPORT_SYMBOL(systemcfg);
+
+asmlinkage void ret_from_sys_call(void);
+EXPORT_SYMBOL_NOVERS(ret_from_sys_call);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/process.c linux-2.6.9/arch/ppc64/kernel/process.c
--- linux-2.6.9-clean/arch/ppc64/kernel/process.c	2004-10-18 15:54:32.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/process.c	2004-10-27 13:58:35.000000000 -0600
@@ -36,6 +36,7 @@
 #include <linux/kallsyms.h>
 #include <linux/interrupt.h>
 #include <linux/version.h>
+#include <linux/bproc.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -517,6 +518,10 @@
 	putname(filename);
 
 out:
+	if (error == -ENOENT)
+		error = bproc_hook_imv(error, sys_execve,
+				       (regs, (char *)a0,
+					(char **)a1, (char **)a2));
 	return error;
 }
 
@@ -629,3 +634,7 @@
 	show_stack(current, (unsigned long *)__get_SP());
 }
 EXPORT_SYMBOL(dump_stack);
+
+void __bproc_kcall(void) {
+	bproc_kcall();
+}
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/ptrace32.c linux-2.6.9/arch/ppc64/kernel/ptrace32.c
--- linux-2.6.9-clean/arch/ppc64/kernel/ptrace32.c	2004-10-18 15:54:32.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/ptrace32.c	2004-10-27 13:58:35.000000000 -0600
@@ -26,6 +26,8 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -53,17 +55,20 @@
 			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
+		bproc_hook_im(ptrace_traceme,());
 		ret = 0;
 		goto out;
 	}
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child = bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		goto out;
+	}
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
@@ -78,6 +83,11 @@
 	if (ret < 0)
 		goto out_tsk;
 
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		goto out_tsk;
+	}
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */ 
@@ -418,3 +428,4 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL_GPL(sys32_ptrace);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/kernel/ptrace.c linux-2.6.9/arch/ppc64/kernel/ptrace.c
--- linux-2.6.9-clean/arch/ppc64/kernel/ptrace.c	2004-10-18 15:54:55.000000000 -0600
+++ linux-2.6.9/arch/ppc64/kernel/ptrace.c	2004-10-27 13:58:35.000000000 -0600
@@ -27,6 +27,8 @@
 #include <linux/user.h>
 #include <linux/security.h>
 #include <linux/audit.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -65,17 +67,20 @@
 			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
+		bproc_hook_im(ptrace_traceme,());
 		ret = 0;
 		goto out;
 	}
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child = bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		goto out;
+	}
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
@@ -90,6 +95,11 @@
 	if (ret < 0)
 		goto out_tsk;
 
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		goto out_tsk;
+	}
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */ 
@@ -282,6 +292,7 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL_GPL(sys_ptrace);
 
 static void do_syscall_trace(void)
 {
@@ -322,3 +333,4 @@
 	    && (current->ptrace & PT_PTRACED))
 		do_syscall_trace();
 }
+EXPORT_SYMBOL_GPL(do_syscall_trace_leave);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/mm/init.c linux-2.6.9/arch/ppc64/mm/init.c
--- linux-2.6.9-clean/arch/ppc64/mm/init.c	2004-10-18 15:54:32.000000000 -0600
+++ linux-2.6.9/arch/ppc64/mm/init.c	2004-10-27 14:32:26.000000000 -0600
@@ -499,6 +499,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(init_new_context);
 
 void destroy_context(struct mm_struct *mm)
 {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/mm/mmap.c linux-2.6.9/arch/ppc64/mm/mmap.c
--- linux-2.6.9-clean/arch/ppc64/mm/mmap.c	2004-10-18 15:53:21.000000000 -0600
+++ linux-2.6.9/arch/ppc64/mm/mmap.c	2004-10-27 14:33:09.000000000 -0600
@@ -26,6 +26,7 @@
 
 #include <linux/personality.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 
 /*
  * Top of mmap area (just below the process stack).
@@ -84,3 +85,4 @@
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
 }
+EXPORT_SYMBOL_GPL(arch_pick_mmap_layout);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/mm/slb.c linux-2.6.9/arch/ppc64/mm/slb.c
--- linux-2.6.9-clean/arch/ppc64/mm/slb.c	2004-10-18 15:54:30.000000000 -0600
+++ linux-2.6.9/arch/ppc64/mm/slb.c	2004-10-27 13:58:35.000000000 -0600
@@ -15,6 +15,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <asm/pgtable.h>
 #include <asm/mmu.h>
 #include <asm/mmu_context.h>
@@ -134,6 +135,7 @@
 		return;
 	slb_allocate(unmapped_base);
 }
+EXPORT_SYMBOL_GPL(switch_slb);
 
 void slb_initialize(void)
 {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/ppc64/mm/stab.c linux-2.6.9/arch/ppc64/mm/stab.c
--- linux-2.6.9-clean/arch/ppc64/mm/stab.c	2004-10-18 15:55:37.000000000 -0600
+++ linux-2.6.9/arch/ppc64/mm/stab.c	2004-10-27 14:33:01.000000000 -0600
@@ -13,6 +13,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <asm/pgtable.h>
 #include <asm/mmu.h>
 #include <asm/mmu_context.h>
@@ -216,6 +217,7 @@
 	/* Order update */
 	asm volatile("sync" : : : "memory");
 }
+EXPORT_SYMBOL_GPL(switch_stab);
 
 extern void slb_initialize(void);
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/ia32/ia32entry.S linux-2.6.9/arch/x86_64/ia32/ia32entry.S
--- linux-2.6.9-clean/arch/x86_64/ia32/ia32entry.S	2004-10-18 15:54:07.000000000 -0600
+++ linux-2.6.9/arch/x86_64/ia32/ia32entry.S	2004-10-27 13:58:35.000000000 -0600
@@ -289,6 +289,8 @@
 	PTREGSCALL stub32_iopl, sys_iopl, %rsi
 	PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx
 
+	PTREGSCALL stub32_bproc, sys_bproc, %rcx
+
 ENTRY(ia32_ptregs_common)
 	CFI_STARTPROC
 	popq %r11
@@ -319,7 +321,7 @@
 	.quad sys_mknod
 	.quad sys_chmod		/* 15 */
 	.quad sys_lchown16
-	.quad quiet_ni_syscall			/* old break syscall holder */
+	.quad stub32_bproc			/* old break syscall holder */
 	.quad sys_stat
 	.quad sys32_lseek
 	.quad sys_getpid		/* 20 */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/ia32/ptrace32.c linux-2.6.9/arch/x86_64/ia32/ptrace32.c
--- linux-2.6.9-clean/arch/x86_64/ia32/ptrace32.c	2004-10-18 15:53:45.000000000 -0600
+++ linux-2.6.9/arch/x86_64/ia32/ptrace32.c	2004-10-27 13:58:35.000000000 -0600
@@ -12,12 +12,14 @@
  */ 
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/stddef.h>
 #include <linux/sched.h>
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
 #include <linux/mm.h>
 #include <linux/ptrace.h>
+#include <linux/bproc.h>
 #include <asm/ptrace.h>
 #include <asm/compat.h>
 #include <asm/uaccess.h>
@@ -205,7 +207,7 @@
 
 	*err = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child = bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
@@ -225,11 +227,12 @@
 	
 } 
 
-asmlinkage long sys32_ptrace(long request, u32 pid, u32 addr, u32 data)
+/* BProc: syscall entry code should have zero-extended these for us. */
+asmlinkage long sys32_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
 	struct pt_regs *childregs; 
-	void __user *datap = compat_ptr(data);
+	void __user *datap = (void *) data;
 	int ret;
 	__u32 val;
 
@@ -254,8 +257,16 @@
 	} 
 
 	child = find_target(request, pid, &ret);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		return ret;
+	}
+
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		put_task_struct(child);
+		return ret;
+	}
 
 	childregs = (struct pt_regs *)(child->thread.rsp0 - sizeof(struct pt_regs)); 
 
@@ -319,7 +330,7 @@
 
 	case PTRACE_GETFPREGS:
 		ret = -EIO; 
-		if (!access_ok(VERIFY_READ, compat_ptr(data), 
+		if (!access_ok(VERIFY_READ, datap, 
 			       sizeof(struct user_i387_struct)))
 			break;
 		save_i387_ia32(child, datap, childregs, 1);
@@ -376,3 +387,4 @@
 	return ret;
 }
 
+EXPORT_SYMBOL_GPL(sys32_ptrace);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/entry.S linux-2.6.9/arch/x86_64/kernel/entry.S
--- linux-2.6.9-clean/arch/x86_64/kernel/entry.S	2004-10-18 15:53:50.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/entry.S	2004-10-27 13:58:35.000000000 -0600
@@ -339,6 +339,8 @@
 	PTREGSCALL stub_sigaltstack, sys_sigaltstack, %rdx
 	PTREGSCALL stub_iopl, sys_iopl, %rsi
 
+	PTREGSCALL stub_bproc, sys_bproc, %rcx
+
 ENTRY(ptregscall_common)
 	CFI_STARTPROC
 	popq %r11
@@ -718,6 +720,18 @@
  */
 ENTRY(kernel_thread)
 	CFI_STARTPROC
+
+	/* BProc: save our args and call bproc_kcall */
+	subq $3*8, %rsp
+	movq %rdi,  0(%rsp)
+	movq %rsi,  8(%rsp)
+	movq %rdx, 16(%rsp)
+	call __bproc_kcall
+	movq  0(%rsp), %rdi
+	movq  8(%rsp), %rsi
+	movq 16(%rsp), %rdx
+	addq $3*8, %rsp
+	
 	FAKE_STACK_FRAME $child_rip
 	SAVE_ALL
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/ldt.c linux-2.6.9/arch/x86_64/kernel/ldt.c
--- linux-2.6.9-clean/arch/x86_64/kernel/ldt.c	2004-10-18 15:55:18.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/ldt.c	2004-10-27 13:58:35.000000000 -0600
@@ -16,6 +16,7 @@
 #include <linux/smp_lock.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -109,6 +110,7 @@
 	}
 	return retval;
 }
+EXPORT_SYMBOL_GPL(init_new_context);
 
 /*
  * 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/process.c linux-2.6.9/arch/x86_64/kernel/process.c
--- linux-2.6.9-clean/arch/x86_64/kernel/process.c	2004-10-18 15:54:31.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/process.c	2004-10-27 13:58:35.000000000 -0600
@@ -33,6 +33,7 @@
 #include <linux/irq.h>
 #include <linux/ptrace.h>
 #include <linux/version.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -545,6 +546,8 @@
 	if (error == 0)
 		current->ptrace &= ~PT_DTRACE;
 	putname(filename);
+	if (error == -ENOENT)
+		error = bproc_hook_imv(error, sys_execve, (&regs, name, argv, envp));
 	return error;
 }
 
@@ -720,3 +723,8 @@
  
 	return 1;
 }
+
+
+void __bproc_kcall(void) {
+	bproc_kcall();
+}
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/ptrace.c linux-2.6.9/arch/x86_64/kernel/ptrace.c
--- linux-2.6.9-clean/arch/x86_64/kernel/ptrace.c	2004-10-18 15:53:46.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/ptrace.c	2004-10-27 13:58:35.000000000 -0600
@@ -17,6 +17,8 @@
 #include <linux/user.h>
 #include <linux/security.h>
 #include <linux/audit.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -198,17 +200,20 @@
 			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
+		bproc_hook_im(ptrace_traceme,());
 		ret = 0;
 		goto out;
 	}
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
-	child = find_task_by_pid(pid);
+	child =  bproc_hook_v(find_task_by_pid(pid), find_task, (pid));
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child) {
+		ret = bproc_hook_v(ret,ptrace_no_proc,(request,pid,addr,data));
 		goto out;
+	}
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
@@ -222,6 +227,11 @@
 	if (ret < 0) 
 		goto out_tsk;
 
+	if (bproc_isghost(child)) {
+		ret = bproc_hook_v(ret,ptrace_ghost,(request,pid,addr,data));
+		goto out_tsk;
+	}
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */ 
@@ -493,6 +503,7 @@
 	unlock_kernel();
 	return ret;
 }
+EXPORT_SYMBOL_GPL(sys_ptrace);
 
 static void syscall_trace(struct pt_regs *regs)
 {
@@ -539,3 +550,4 @@
 	    && (current->ptrace & PT_PTRACED))
 		syscall_trace(regs);
 }
+EXPORT_SYMBOL_GPL(syscall_trace_leave);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/sys_x86_64.c linux-2.6.9/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.9-clean/arch/x86_64/kernel/sys_x86_64.c	2004-10-18 15:54:38.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/sys_x86_64.c	2004-10-27 13:58:35.000000000 -0600
@@ -2,6 +2,7 @@
  * linux/arch/x86_64/kernel/sys_x86_64.c
  */
 
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/syscalls.h>
@@ -141,6 +142,7 @@
 		addr = vma->vm_end;
 	}
 }
+EXPORT_SYMBOL_GPL(arch_get_unmapped_area);
 
 asmlinkage long sys_uname(struct new_utsname __user * name)
 {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/arch/x86_64/kernel/x8664_ksyms.c linux-2.6.9/arch/x86_64/kernel/x8664_ksyms.c
--- linux-2.6.9-clean/arch/x86_64/kernel/x8664_ksyms.c	2004-10-18 15:53:22.000000000 -0600
+++ linux-2.6.9/arch/x86_64/kernel/x8664_ksyms.c	2004-10-27 13:58:35.000000000 -0600
@@ -220,3 +220,9 @@
 #endif
 
 EXPORT_SYMBOL(cpu_khz);
+
+EXPORT_SYMBOL_GPL(cpu_gdt_table);
+extern void int_ret_from_sys_call(void);
+EXPORT_SYMBOL_GPL(int_ret_from_sys_call);
+extern void load_gs_index(unsigned);
+EXPORT_SYMBOL_GPL(load_gs_index);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/binfmt_script.c linux-2.6.9/fs/binfmt_script.c
--- linux-2.6.9-clean/fs/binfmt_script.c	2004-10-18 15:53:21.000000000 -0600
+++ linux-2.6.9/fs/binfmt_script.c	2004-10-27 13:58:35.000000000 -0600
@@ -15,6 +15,7 @@
 #include <linux/smp_lock.h>
 #include <linux/err.h>
 #include <linux/fs.h>
+#include <linux/bproc.h>
 
 static int load_script(struct linux_binprm *bprm,struct pt_regs *regs)
 {
@@ -69,7 +70,7 @@
 	 * user environment and arguments are stored.
 	 */
 	remove_arg_zero(bprm);
-	retval = copy_strings_kernel(1, &bprm->interp, bprm);
+	retval = copy_strings_kernel(1,bproc_hook_v(&bprm->filename,load_script,(&bprm->filename)), bprm);
 	if (retval < 0) return retval; 
 	bprm->argc++;
 	if (i_arg) {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/compat.c linux-2.6.9/fs/compat.c
--- linux-2.6.9-clean/fs/compat.c	2004-10-18 15:54:07.000000000 -0600
+++ linux-2.6.9/fs/compat.c	2004-10-27 13:58:35.000000000 -0600
@@ -1477,6 +1477,7 @@
 out_ret:
 	return retval;
 }
+EXPORT_SYMBOL_GPL(compat_do_execve);
 
 #define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/exec.c linux-2.6.9/fs/exec.c
--- linux-2.6.9-clean/fs/exec.c	2004-10-18 15:53:51.000000000 -0600
+++ linux-2.6.9/fs/exec.c	2004-10-27 13:58:35.000000000 -0600
@@ -46,6 +46,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/rmap.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1162,6 +1163,7 @@
 		/* execve success */
 		security_bprm_free(bprm);
 		kfree(bprm);
+		bproc_hook_im(do_execve,());
 		return retval;
 	}
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/fcntl.c linux-2.6.9/fs/fcntl.c
--- linux-2.6.9-clean/fs/fcntl.c	2004-10-18 15:54:38.000000000 -0600
+++ linux-2.6.9/fs/fcntl.c	2004-10-27 13:58:35.000000000 -0600
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/bproc.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -201,6 +202,7 @@
 	fput(file);
 	goto out;
 }
+EXPORT_SYMBOL_GPL(sys_dup2);
 
 asmlinkage long sys_dup(unsigned int fildes)
 {
@@ -264,7 +266,7 @@
 {
 	write_lock_irq(&filp->f_owner.lock);
 	if (force || !filp->f_owner.pid) {
-		filp->f_owner.pid = pid;
+		filp->f_owner.pid = bproc_hook_imv(pid, localpid, (pid));
 		filp->f_owner.uid = uid;
 		filp->f_owner.euid = euid;
 	}
@@ -330,7 +332,7 @@
 		 * current syscall conventions, the only way
 		 * to fix this will be in libc.
 		 */
-		err = filp->f_owner.pid;
+		err = bproc_hook_imv(filp->f_owner.pid, masqpid, (filp->f_owner.pid));
 		force_successful_syscall_return();
 		break;
 	case F_SETOWN:
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/open.c linux-2.6.9/fs/open.c
--- linux-2.6.9-clean/fs/open.c	2004-10-18 15:53:08.000000000 -0600
+++ linux-2.6.9/fs/open.c	2004-10-27 13:58:35.000000000 -0600
@@ -535,6 +535,7 @@
 out:
 	return error;
 }
+EXPORT_SYMBOL_GPL(sys_chdir);
 
 asmlinkage long sys_fchdir(unsigned int fd)
 {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/proc/array.c linux-2.6.9/fs/proc/array.c
--- linux-2.6.9-clean/fs/proc/array.c	2004-10-18 15:54:32.000000000 -0600
+++ linux-2.6.9/fs/proc/array.c	2004-10-27 13:58:35.000000000 -0600
@@ -73,6 +73,7 @@
 #include <linux/highmem.h>
 #include <linux/file.h>
 #include <linux/times.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -137,7 +138,8 @@
 
 static inline const char * get_task_state(struct task_struct *tsk)
 {
-	unsigned int state = tsk->state & (TASK_RUNNING |
+	unsigned int state = (bproc_hook_v(tsk->state,task_state,(tsk)))
+		                        & (TASK_RUNNING |
 					   TASK_INTERRUPTIBLE |
 					   TASK_UNINTERRUPTIBLE |
 					   TASK_ZOMBIE |
@@ -170,8 +172,9 @@
 		"Gid:\t%d\t%d\t%d\t%d\n",
 		get_task_state(p),
 		(p->sleep_avg/1024)*100/(1020000000/1024),
-	       	p->tgid,
-		p->pid, p->pid ? p->real_parent->pid : 0,
+		bproc_hook_imv(p->tgid, proc_tgid, (p)),
+		bproc_hook_imv(p->pid, proc_pid, (p)),
+		bproc_hook_imv(p->real_parent->pid, proc_ppid, (p)),
 		p->pid && p->ptrace ? p->parent->pid : 0,
 		p->uid, p->euid, p->suid, p->fsuid,
 		p->gid, p->egid, p->sgid, p->fsgid);
@@ -280,6 +283,11 @@
 			    cap_t(p->cap_effective));
 }
 
+static inline char *task_node(struct task_struct *p, char *buffer) {
+	return buffer + sprintf(buffer, "BProcNode:\t%d\n",
+				bproc_hook_v(-1, proc_nodeid, (p)));
+}
+
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
 	char * orig = buffer;
@@ -291,12 +299,16 @@
 	if (mm) {
 		buffer = task_mem(mm, buffer);
 		mmput(mm);
+	} else {
+		/* BProc: this might be a ghost so try that route */
+		buffer = bproc_hook_v(buffer, proc_task_mem, (task, buffer));
 	}
 	buffer = task_sig(task, buffer);
 	buffer = task_cap(task, buffer);
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
+	buffer = task_node(task, buffer);
 	return buffer - orig;
 }
 
@@ -308,7 +320,7 @@
 	sigset_t sigign, sigcatch;
 	char state;
 	int res;
- 	pid_t ppid, pgid = -1, sid = -1;
+ 	pid_t pid, ppid, pgid = -1, sid = -1;
 	int num_threads = 0;
 	struct mm_struct *mm;
 	unsigned long long start_time;
@@ -356,7 +368,9 @@
 	nice = task_nice(task);
 
 	read_lock(&tasklist_lock);
-	ppid = task->pid ? task->real_parent->pid : 0;
+	pid  = bproc_hook_imv(task->pid, proc_pid, (task));
+	ppid = bproc_hook_imv(task->pid ? task->real_parent->pid : 0,
+			      proc_ppid, (task));
 	read_unlock(&tasklist_lock);
 
 	/* Temporary variable needed for gcc-2.96 */
@@ -369,7 +383,7 @@
 	res = sprintf(buffer,"%d (%s) %c %d %d %d %d %d %lu %lu \
 %lu %lu %lu %lu %lu %ld %ld %ld %ld %d %ld %llu %lu %ld %lu %lu %lu %lu %lu \
 %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %lu\n",
-		task->pid,
+		pid,
 		tcomm,
 		state,
 		ppid,
@@ -427,6 +441,10 @@
 	if (mm) {
 		size = task_statm(mm, &shared, &text, &data, &resident);
 		mmput(mm);
+	} else {
+		/* BProc: this might be a ghost so try that route */
+		size = bproc_hook_v(size, proc_task_statm,
+				    (task, &shared, &text, &data, &resident));
 	}
 
 	return sprintf(buffer,"%d %d %d %d %d %d %d\n",
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/fs/proc/base.c linux-2.6.9/fs/proc/base.c
--- linux-2.6.9-clean/fs/proc/base.c	2004-10-18 15:54:37.000000000 -0600
+++ linux-2.6.9/fs/proc/base.c	2004-10-27 13:58:35.000000000 -0600
@@ -32,6 +32,7 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/bproc.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -224,8 +225,11 @@
 	struct task_struct *task = proc_task(inode);
 	struct mm_struct * mm = get_task_mm(task);
 
-	if (!mm)
+	if (!mm) {
+		/* BProc: try our way to find an exe link */
+		result = bproc_hook_v(result, proc_exe, (task, dentry, mnt));
 		goto out;
+	}
 	down_read(&mm->mmap_sem);
 	vma = mm->mmap;
 	while (vma) {
@@ -551,6 +555,7 @@
 	if (!(page = __get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
 
+	if (bproc_isghost(task)) bproc_hook(refresh_status, (task));
 	length = PROC_I(inode)->op.proc_read(task, (char*)page);
 
 	if (length >= 0)
@@ -928,6 +933,8 @@
 	mm = task->mm;
 	if (mm)
 		dumpable = mm->dumpable;
+	else
+		dumpable = bproc_hook_v(0, proc_dumpable, (task));
 	task_unlock(task);
 	return dumpable;
 }
@@ -1470,14 +1477,14 @@
 			      int buflen)
 {
 	char tmp[30];
-	sprintf(tmp, "%d", current->tgid);
+	sprintf(tmp, "%d", bproc_hook_imv(current->tgid,proc_self,()));
 	return vfs_readlink(dentry,buffer,buflen,tmp);
 }
 
 static int proc_self_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	char tmp[30];
-	sprintf(tmp, "%d", current->tgid);
+	sprintf(tmp, "%d", bproc_hook_imv(current->tgid,proc_self,()));
 	return vfs_follow_link(nd,tmp);
 }	
 
@@ -1564,6 +1571,7 @@
 	if (tgid == ~0U)
 		goto out;
 
+	tgid = bproc_hook_imv(tgid, proc_lookup,(tgid));
 	read_lock(&tasklist_lock);
 	task = find_task_by_pid(tgid);
 	if (task)
@@ -1619,6 +1627,7 @@
 	if (tid == ~0U)
 		goto out;
 
+	tid = bproc_hook_imv(tid, proc_lookup, (tid));
 	read_lock(&tasklist_lock);
 	task = find_task_by_pid(tid);
 	if (task)
@@ -1680,9 +1689,11 @@
 		p = next_task(&init_task);
 
 	for ( ; p != &init_task; p = next_task(p)) {
-		int tgid = p->pid;
+		int tgid = bproc_hook_imv(p->pid,proc_masq_only,(p));
 		if (!pid_alive(p))
 			continue;
+		if (tgid == 0)
+			continue;
 		if (--index >= 0)
 			continue;
 		tgids[nr_tgids] = tgid;
@@ -1713,8 +1724,10 @@
 	 * via next_thread().
 	 */
 	if (pid_alive(task)) do {
-		int tid = task->pid;
+		int tid = bproc_hook_imv(task->pid,proc_masq_only,(task));
 
+		if (tid == 0)
+			continue;
 		if (--index >= 0)
 			continue;
 		tids[nr_tids] = tid;
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/include/asm-x86_64/unistd.h linux-2.6.9/include/asm-x86_64/unistd.h
--- linux-2.6.9-clean/include/asm-x86_64/unistd.h	2004-10-18 15:54:39.000000000 -0600
+++ linux-2.6.9/include/asm-x86_64/unistd.h	2004-10-27 13:58:35.000000000 -0600
@@ -424,7 +424,9 @@
 __SYSCALL(__NR_afs_syscall, sys_ni_syscall)
 
 #define __NR_tuxcall      		184 /* reserved for tux */
-__SYSCALL(__NR_tuxcall, sys_ni_syscall)
+     /*__SYSCALL(__NR_tuxcall, sys_ni_syscall)*/
+/* BProc: We're using this one, sorry. */
+__SYSCALL(__NR_tuxcall, stub_bproc)
 
 #define __NR_security			185
 __SYSCALL(__NR_security, sys_ni_syscall)
@@ -684,6 +686,7 @@
 #include <linux/syscalls.h>
 #include <asm/ptrace.h>
 
+#include <linux/bproc.h>
 /*
  * we need this inline - forking from kernel space will result
  * in NO COPY ON WRITE (!!!), until an execve is executed. This
@@ -738,6 +741,7 @@
 
 static inline pid_t waitpid(int pid, int * wait_stat, int flags)
 {
+	bproc_kcall();
 	return sys_wait4(pid, wait_stat, flags, NULL);
 }
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/include/linux/bproc.h linux-2.6.9/include/linux/bproc.h
--- linux-2.6.9-clean/include/linux/bproc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.9/include/linux/bproc.h	2004-10-27 13:58:35.000000000 -0600
@@ -0,0 +1,115 @@
+/*-------------------------------------------------------------------------
+ *  bproc.h: Beowulf distributed PID space (bproc) definitions
+ *
+ *  Copyright (C) 1999-2001 by Erik Hendriks <erik@hendriks.cx>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: bproc-patch-2.6.9,v 1.2 2004/10/27 20:46:29 ehendriks Exp $
+ *-----------------------------------------------------------------------*/
+#ifndef _LINUX_BPROC_H
+#define _LINUX_BPROC_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/rwsem.h>
+
+#ifdef CONFIG_BPROC
+
+/* Include prototypes for all the hook functions */
+#define bprocdeclhook(ret,func,args)  \
+     extern ret (* bproc_hook_ ## func ## _hook) args
+#include <linux/bproc_hooks.h>
+#undef bprocdeclhook
+
+/* BProc process flags */
+#define BPROC_FLAG_KCALL            0
+#define BPROC_FLAG_NO_KCALL         1
+#define BPROC_FLAG_EXECMOVE         2
+#define BPROC_FLAG_SCRIPT           3
+#define BPROC_FLAG_PTRACE_3RD_PARTY 4
+#define BPROC_FLAG_STOPPED          5
+#define BPROC_FLAG_PEXIT            6 /* parent exit needs to be sent */
+
+/* Macro suffixes:
+ * (none)   = execute this hook if it's present.
+ * im       = if masq'ed
+ * nkc      = no kernel call (kcall must be 0 to call hook)
+ * r        = return the value of this hook
+ * v        = hook returns a value.
+ */
+#define hookname(func) bproc_hook_ ## func ## _hook
+#define bproc_hook(func,args)          do{if(hookname(func))hookname(func)args;}while(0)
+#define bproc_hook_im(func,args)       do{if(hookname(func)&&current->bproc.master)hookname(func)args;}while(0)
+#define bproc_hook_imr(func,args)      do{if(hookname(func)&&current->bproc.master)return hookname(func)args;}while(0)
+#define bproc_hook_v(defl,func,args)   ( hookname(func)                      ?hookname(func)args:defl)
+#define bproc_hook_imv(defl,func,args) ((hookname(func)&&current->bproc.master)?hookname(func)args:defl)
+
+#define bproc_isghost(tsk)             ((tsk)->bproc.ghost != 0)
+#define bproc_ismasq(tsk)              ((tsk)->bproc.master != 0)
+#define bproc_set_arg(x)               do{current->bproc.arg=(x);}while(0)
+
+/* Kernel call weirdness... a kernel call is a call made from the
+ * kernel which we do not want to be subject to the usual rules for
+ * PID masquerading.  This is mostly used for drivers which create and
+ * possibly wait for kernel threads which they create.  These
+ * functions are called from the relevant places within the kernel
+ * (like within kernel_thread) to set a flag so that things will be
+ * handled correctly later on. */
+static inline void bproc_no_kcall(void) {
+    clear_bit(BPROC_FLAG_KCALL, &current->bproc.flag);
+    set_bit  (BPROC_FLAG_NO_KCALL, &current->bproc.flag);
+}
+static inline void bproc_clear_kcall(void) {
+    clear_bit(BPROC_FLAG_KCALL,    &current->bproc.flag);
+    clear_bit(BPROC_FLAG_NO_KCALL, &current->bproc.flag);
+}
+static inline void bproc_kcall(void) {
+    if (!test_bit(BPROC_FLAG_NO_KCALL, &current->bproc.flag))
+	set_bit(BPROC_FLAG_KCALL, &current->bproc.flag);
+    else
+	bproc_clear_kcall();
+}
+
+
+/* Other misc BProc related stuff */
+extern spinlock_t bproc_ptrace_attach_lock;
+extern struct rw_semaphore do_bproc_lock;
+extern long (*do_bproc_ptr)(long,long,long,struct pt_regs *);
+
+extern long sys_bproc(long, long, long, struct pt_regs *);
+
+#else
+/* Stubs for when hooks are not compiled in */
+#define bproc_hook(func,args)          do{}while(0)
+#define bproc_hook_im(func,args)       do{}while(0)
+#define bproc_hook_imr(func,args)      do{}while(0)
+#define bproc_hook_v(defl,func,args)   (defl)
+#define bproc_hook_imv(defl,func,args) (defl)
+#define bproc_isghost(tsk)             (0)
+#define bproc_ismasq(tsk)              (0)
+#define bproc_set_arg(x)               do{}while(0)
+#define bproc_no_kcall()               do{}while(0)
+#define bproc_clear_kcall()            do{}while(0)
+#define bproc_kcall()                  do{}while(0)
+#endif
+#endif
+
+/*
+ * Local variables:
+ * c-basic-offset: 4
+ * End:
+ */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/include/linux/bproc_hooks.h linux-2.6.9/include/linux/bproc_hooks.h
--- linux-2.6.9-clean/include/linux/bproc_hooks.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.9/include/linux/bproc_hooks.h	2004-10-27 13:58:35.000000000 -0600
@@ -0,0 +1,79 @@
+/*--------------------------------------------------------------------
+ * This is the list of hooks.  The file gets included by other files
+ * that define the bprocdeclhook macro.  That turns this list into a
+ * list of prototypes or whatever is required.
+ *
+ * $Id: bproc-patch-2.6.9,v 1.2 2004/10/27 20:46:29 ehendriks Exp $
+ *------------------------------------------------------------------*/
+
+/*----- Generic/reusable hooks ------------------------------------------*/
+bprocdeclhook(struct task_struct *, find_task,  (int));
+bprocdeclhook(long                , task_state, (struct task_struct *));
+bprocdeclhook(int                 , masq_pid,   (struct task_struct *));
+bprocdeclhook(int                 , masq_tgid,  (struct task_struct *));
+bprocdeclhook(int                 , masqpid,    (int));
+bprocdeclhook(int                 , localpid,   (int));
+
+/*----- fs/exec.c -------------------------------------------------------*/
+bprocdeclhook(void,  do_execve,       (void));
+/*----- fs/binfmt_script.c ----------------------------------------------*/
+bprocdeclhook(char**,load_script,     (char **));
+/*----- fs/proc/array.c ----------------------------------------------------*/
+bprocdeclhook(void,  refresh_status,  (struct task_struct *));
+bprocdeclhook(int,   proc_pid,        (struct task_struct *));
+bprocdeclhook(int,   proc_tgid,       (struct task_struct *));
+bprocdeclhook(int,   proc_ppid,       (struct task_struct *));
+bprocdeclhook(int,   proc_masq_only,  (struct task_struct *));
+bprocdeclhook(int,   proc_lookup,     (int));
+bprocdeclhook(int,   proc_self,       (void));
+bprocdeclhook(int,   proc_nodeid,     (struct task_struct *));
+bprocdeclhook(int,   proc_exe,        (struct task_struct *, struct dentry **,
+				       struct vfsmount **));
+bprocdeclhook(int,   proc_dumpable,   (struct task_struct *));
+bprocdeclhook(char*, proc_task_mem,   (struct task_struct *, char *));
+bprocdeclhook(int,   proc_task_statm, (struct task_struct *, int *, int *,
+				       int *, int *));
+/*----- kernel/timer.c --------------------------------------------------*/
+bprocdeclhook(int,   sys_getppid,     (struct task_struct *));
+/*----- kernel/sched.c --------------------------------------------------*/
+bprocdeclhook(void,  schedule_in,     (void));
+bprocdeclhook(void,  schedule_out,    (void));
+/*----- kernel/exit.c ---------------------------------------------------*/
+bprocdeclhook(void,  release,         (struct task_struct *));
+bprocdeclhook(int,   is_orphaned_pgrp,(int));
+/*bprocdeclhook(struct task_struct *,child_reaper,(struct task_struct *));*/
+bprocdeclhook(void,  do_exit,         (struct task_struct *, long code));
+bprocdeclhook(void,  forget_parent,   (int send_pexit));
+bprocdeclhook(int,   sys_wait4_1,     (pid_t *, int, struct siginfo *,
+				       unsigned int *, struct rusage *, int*));
+bprocdeclhook(int,   sys_wait4_3,     (struct task_struct *));
+bprocdeclhook(void,  sys_wait4_4,     (pid_t, int options));
+/*----- kernel/fork.c ---------------------------------------------------*/
+bprocdeclhook(int,   copy_process,    (struct task_struct *, unsigned long));
+bprocdeclhook(void,  copy_process_2,  (struct task_struct *));
+bprocdeclhook(void,  copy_process_cleanup, (struct task_struct *));
+bprocdeclhook(int,   do_fork,         (struct task_struct *));
+/*----- kernel/signal.c -------------------------------------------------*/
+/*bprocdeclhook(int,   send_sig_info,   (int, struct siginfo *,
+  struct task_struct *));*/
+bprocdeclhook(int,   kill_pg_info,    (int, struct siginfo *, pid_t));
+bprocdeclhook(int,   kill_proc_info,  (int, struct siginfo *, pid_t));
+/*----- kernel/sys.c ----------------------------------------------------*/
+bprocdeclhook(int,   sys_setpgid_m,   (pid_t, pid_t));
+bprocdeclhook(void,  sys_setpgid_g,   (struct task_struct *p));
+bprocdeclhook(int,   sys_getpgid,     (pid_t pid));
+
+bprocdeclhook(int,   sys_getsid,     (pid_t pid));
+bprocdeclhook(int,   sys_setsid,      (void));
+
+bprocdeclhook(void,  set_creds,       (void));
+/*----- arch/???/kernel/ptrace.c,signal.c -------------------------------*/
+bprocdeclhook(long,                 ptrace_no_proc, (long, long, long, long));
+bprocdeclhook(long,                 ptrace_ghost,   (long, long, long, long));
+bprocdeclhook(int,                  ptrace_check_attach,(struct task_struct*));
+bprocdeclhook(struct task_struct *, ptrace_attach,  (struct task_struct *));
+bprocdeclhook(void,                 ptrace_traceme, (void));
+bprocdeclhook(void,                 ptrace_detach,  (struct task_struct *));
+
+bprocdeclhook(int,   sys_execve,      (struct pt_regs *, char *,
+				       char **, char **));
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/include/linux/sched.h linux-2.6.9/include/linux/sched.h
--- linux-2.6.9-clean/include/linux/sched.h	2004-10-18 15:53:13.000000000 -0600
+++ linux-2.6.9/include/linux/sched.h	2004-10-27 13:58:35.000000000 -0600
@@ -312,6 +312,13 @@
 	unsigned long utime, stime, cutime, cstime;
 	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+
+#ifdef CONFIG_BPROC
+	struct {
+		pid_t pgrp;
+		pid_t session;
+	} bproc;
+#endif
 };
 
 /*
@@ -584,6 +591,25 @@
   	struct mempolicy *mempolicy;
   	short il_next;		/* could be shared with used_math */
 #endif
+
+/* bproc */
+#ifdef CONFIG_BPROC
+	struct {
+		long flag;
+		long arg;
+		struct bproc_masq_master_t *context;
+
+		/* Slave MASQ stuff */
+		struct bproc_masq_master_t *master;
+		struct list_head list;
+		pid_t pid, tgid, ppid, oppid;
+		int  nlchild;
+		long last_update;
+		
+		/* Ghost process stuff */
+		struct bproc_ghost_proc_t  *ghost;
+	} bproc;
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/init/Kconfig linux-2.6.9/init/Kconfig
--- linux-2.6.9-clean/init/Kconfig	2004-10-18 15:54:55.000000000 -0600
+++ linux-2.6.9/init/Kconfig	2004-10-27 13:58:35.000000000 -0600
@@ -133,6 +133,11 @@
 	  for processing it. A preliminary version of these tools is available
 	  at <http://www.physik3.uni-rostock.de/tim/kernel/utils/acct/>.
 
+config BPROC
+	bool "BProc support"
+	help
+	  This option adds the hooks that BProc requires to the kernel.
+
 config SYSCTL
 	bool "Sysctl support"
 	---help---
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/init/main.c linux-2.6.9/init/main.c
--- linux-2.6.9-clean/init/main.c	2004-10-18 15:53:23.000000000 -0600
+++ linux-2.6.9/init/main.c	2004-10-27 13:58:35.000000000 -0600
@@ -582,6 +582,7 @@
 __setup("initcall_debug", initcall_debug_setup);
 
 struct task_struct *child_reaper = &init_task;
+EXPORT_SYMBOL_GPL(child_reaper);
 
 extern initcall_t __initcall_start, __initcall_end;
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/bproc_hook.c linux-2.6.9/kernel/bproc_hook.c
--- linux-2.6.9-clean/kernel/bproc_hook.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.9/kernel/bproc_hook.c	2004-10-27 13:58:35.000000000 -0600
@@ -0,0 +1,62 @@
+/*-------------------------------------------------------------------------
+ *  bproc_hook.c: Beowulf distributed PID space (bproc) definitions
+ *
+ *  Copyright (C) 2000 by Erik Hendriks <hendriks@scyld.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: bproc-patch-2.6.9,v 1.2 2004/10/27 20:46:29 ehendriks Exp $
+ *-----------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/bproc.h>
+
+#ifdef CONFIG_BPROC
+
+/* Declare the function pointer and add EXPORT_SYMBOL lines for each
+ * hook. */
+#define bprocdeclhook(ret,func,args) \
+        ret (* bproc_hook_ ## func ## _hook) args = 0;\
+        EXPORT_SYMBOL( bproc_hook_ ## func ## _hook )
+#include <linux/bproc_hooks.h>
+#undef  bprocdeclhook
+
+/* Misc locks and stuff */
+spinlock_t bproc_ptrace_attach_lock = SPIN_LOCK_UNLOCKED;
+DECLARE_RWSEM(do_bproc_lock);
+long (*do_bproc_ptr)(long,long,long,struct pt_regs *) = 0;
+
+EXPORT_SYMBOL_GPL(bproc_ptrace_attach_lock);
+EXPORT_SYMBOL_GPL(do_bproc_ptr);
+EXPORT_SYMBOL_GPL(do_bproc_lock);
+#endif
+
+long sys_bproc(long a1, long a2, long a3, struct pt_regs *regs) {
+    long retval = -ENOSYS;
+#ifdef CONFIG_BPROC
+    /*down_read(&do_bproc_lock);*/
+    if (do_bproc_ptr)
+	retval = do_bproc_ptr(a1,a2,a3,regs);
+    /*up_read(&do_bproc_lock);*/
+#endif
+    return retval;
+}
+
+/*
+ * Local variables:
+ * c-basic-offset: 4
+ * End:
+ */
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/exit.c linux-2.6.9/kernel/exit.c
--- linux-2.6.9-clean/kernel/exit.c	2004-10-18 15:55:06.000000000 -0600
+++ linux-2.6.9/kernel/exit.c	2004-10-27 13:58:35.000000000 -0600
@@ -24,6 +24,7 @@
 #include <linux/mount.h>
 #include <linux/proc_fs.h>
 #include <linux/mempolicy.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -57,6 +58,7 @@
 	struct dentry *proc_dentry;
 
 repeat: 
+	bproc_hook(release,(p));
 	atomic_dec(&p->user->processes);
 	spin_lock(&p->proc_lock);
 	proc_dentry = proc_pid_unhash(p);
@@ -174,11 +176,13 @@
 	int retval;
 
 	read_lock(&tasklist_lock);
-	retval = will_become_orphaned_pgrp(pgrp, NULL);
+	retval = bproc_hook_imv(will_become_orphaned_pgrp(pgrp, 0),
+				is_orphaned_pgrp,(pgrp));
 	read_unlock(&tasklist_lock);
 
 	return retval;
 }
+EXPORT_SYMBOL_GPL(is_orphaned_pgrp);
 
 static inline int has_stopped_jobs(int pgrp)
 {
@@ -593,6 +597,7 @@
 {
 	struct task_struct *p, *reaper = father;
 	struct list_head *_p, *_n;
+	int bproc_send_pexit = 0;
 
 	do {
 		reaper = next_thread(reaper);
@@ -614,6 +619,9 @@
 		int ptrace;
 		p = list_entry(_p,struct task_struct,sibling);
 
+		/* BProc: keep track of whether or not we need to send pexit */
+		if (bproc_isghost(p)) bproc_send_pexit = 1;
+
 		ptrace = p->ptrace;
 
 		/* if father isn't the real parent, then ptrace must be enabled */
@@ -642,9 +650,13 @@
 	}
 	list_for_each_safe(_p, _n, &father->ptrace_children) {
 		p = list_entry(_p,struct task_struct,ptrace_list);
+		/* BProc: keep track of whether or not we need to send pexit */
+		if (bproc_isghost(p)) bproc_send_pexit = 1;
 		choose_new_parent(p, reaper, child_reaper);
 		reparent_thread(p, father, 1);
 	}
+
+	bproc_hook(forget_parent,(bproc_send_pexit));
 }
 
 /*
@@ -708,7 +720,7 @@
 	 
 	t = tsk->real_parent;
 	
-	if ((process_group(t) != process_group(tsk)) &&
+	if (!bproc_ismasq(current) && (process_group(t) != process_group(tsk)) &&
 	    (t->signal->session == tsk->signal->session) &&
 	    will_become_orphaned_pgrp(process_group(tsk), tsk) &&
 	    has_stopped_jobs(process_group(tsk))) {
@@ -794,6 +806,9 @@
 		panic("Attempted to kill init!");
 	if (tsk->io_context)
 		exit_io_context();
+
+	bproc_hook(do_exit,(tsk,code));
+
 	tsk->flags |= PF_EXITING;
 	del_timer_sync(&tsk->real_timer);
 
@@ -834,6 +849,7 @@
 	/* Avoid "noreturn function does return".  */
 	for (;;) ;
 }
+EXPORT_SYMBOL_GPL(do_exit);
 
 NORET_TYPE void complete_and_exit(struct completion *comp, long code)
 {
@@ -1094,7 +1110,9 @@
 		p->state = TASK_ZOMBIE;
 		return retval;
 	}
-	retval = p->pid;
+	/* BProc: (SLAVE) map the process ID from the local process ID
+	 * to the masqueraded process ID. */
+	retval = bproc_hook_imv(p->pid, sys_wait4_3, (p));
 	if (p->real_parent != p->parent) {
 		write_lock_irq(&tasklist_lock);
 		/* Double-check with lock held.  */
@@ -1174,7 +1192,7 @@
 	 * race with the TASK_ZOMBIE case.
 	 */
 	exit_code = xchg(&p->exit_code, 0);
-	if (unlikely(p->state >= TASK_ZOMBIE)) {
+	if (unlikely(bproc_hook_v(p->state,task_state,(p)) >= TASK_ZOMBIE)) {
 		/*
 		 * The task resumed and then died.  Let the next iteration
 		 * catch it in TASK_ZOMBIE.  Note that exit_code might
@@ -1221,25 +1239,32 @@
 	if (!retval && infop)
 		retval = put_user(p->uid, &infop->si_uid);
 	if (!retval)
-		retval = p->pid;
+		/* BProc: (SLAVE) map the process ID from the local
+		 * process ID to the masqueraded process ID. */
+		retval = bproc_hook_imv(p->pid, sys_wait4_3, (p));
 	put_task_struct(p);
 
 	BUG_ON(!retval);
 	return retval;
 }
 
-static long do_wait(pid_t pid, int options, struct siginfo __user *infop,
-		    int __user *stat_addr, struct rusage __user *ru)
+long do_wait(pid_t pid, int options, struct siginfo __user *infop,
+	     int __user *stat_addr, struct rusage __user *ru)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct task_struct *tsk;
 	int flag, retval;
+	pid_t orig_pid = pid;
 
 	add_wait_queue(&current->wait_chldexit,&wait);
 repeat:
 	flag = 0;
 	current->state = TASK_INTERRUPTIBLE;
 	read_lock(&tasklist_lock);
+	pid = orig_pid;
+	if (bproc_hook_imv(0,sys_wait4_1,(&pid, options, infop, stat_addr,
+					  ru, &retval)))
+		goto end;		/* handler will unlock tasklist_lock */
 	tsk = current;
 	do {
 		struct task_struct *p;
@@ -1254,8 +1279,12 @@
 				continue;
 			flag = 1;
 
-			switch (p->state) {
+			switch (bproc_hook_v(p->state,task_state,(p))) {
 			case TASK_TRACED:
+				/* BProc: we can't have child_reaper
+				 * picking up our ptrace stops... */
+				if (current == child_reaper)
+					continue;
 				if (!(p->ptrace & PT_PTRACED))
 					continue;
 				/*FALLTHROUGH*/
@@ -1281,8 +1310,15 @@
 				retval = wait_task_zombie(
 					p, (options & WNOWAIT),
 					infop, stat_addr, ru);
-				if (retval != 0) /* He released the lock.  */
+				if (retval != 0) { /* He released the lock.  */
+					/* BProc: (SLAVE) notify the
+					 * front end that we have
+					 * successfully waited on a
+					 * zombie. */
+					bproc_hook_im(sys_wait4_4,(retval, options));
+
 					goto end;
+				}
 				break;
 			case TASK_DEAD:
 				continue;
@@ -1346,6 +1382,7 @@
 end:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&current->wait_chldexit,&wait);
+	bproc_clear_kcall();
 	if (infop) {
 		if (retval > 0)
 		retval = 0;
@@ -1371,6 +1408,7 @@
 	}
 	return retval;
 }
+EXPORT_SYMBOL_GPL(do_wait);
 
 asmlinkage long sys_waitid(int which, pid_t pid,
 			   struct siginfo __user *infop, int options,
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/fork.c linux-2.6.9/kernel/fork.c
--- linux-2.6.9-clean/kernel/fork.c	2004-10-18 15:53:13.000000000 -0600
+++ linux-2.6.9/kernel/fork.c	2004-10-27 13:58:35.000000000 -0600
@@ -38,6 +38,7 @@
 #include <linux/audit.h>
 #include <linux/profile.h>
 #include <linux/rmap.h>
+#include <linux/bproc.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -99,6 +100,7 @@
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
+EXPORT_SYMBOL_GPL(__put_task_struct);
 
 void fastcall add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait)
 {
@@ -414,6 +416,8 @@
 
 spinlock_t mmlist_lock __cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
 int mmlist_nr;
+EXPORT_SYMBOL_GPL(mmlist_lock);
+EXPORT_SYMBOL_GPL(mmlist_nr);
 
 #define allocate_mm()	(kmem_cache_alloc(mm_cachep, SLAB_KERNEL))
 #define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))
@@ -439,6 +443,7 @@
 	free_mm(mm);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(mm_alloc);
 
 /*
  * Allocate and initialize an mm_struct.
@@ -467,6 +472,7 @@
 	destroy_context(mm);
 	free_mm(mm);
 }
+EXPORT_SYMBOL_GPL(__mmdrop);
 
 /*
  * Decrement the use count and release all resources for an mm.
@@ -890,7 +896,7 @@
 {
 	current->clear_child_tid = tidptr;
 
-	return current->pid;
+	return bproc_hook_imv(current->pid, masq_pid, (current));
 }
 
 /*
@@ -939,6 +945,18 @@
 	if (!p)
 		goto fork_out;
 
+#ifdef CONFIG_BPROC
+	/* BProc: (ALL) clear out the BProc data structures in the
+	 * child.  These will be setup later if necessary. */
+	p->bproc.flag    = 0;
+	p->bproc.arg     = 0;
+	p->bproc.context = 0;
+	p->bproc.master  = 0;
+	p->bproc.pid = p->bproc.tgid = p->bproc.ppid = p->bproc.oppid = 0;
+	p->bproc.nlchild = 0;
+	p->bproc.last_update = 0;
+	p->bproc.ghost = 0;
+
 	retval = -EAGAIN;
 	if (atomic_read(&p->user->processes) >=
 			p->rlim[RLIMIT_NPROC].rlim_cur) {
@@ -946,6 +964,14 @@
 				p->user != &root_user)
 			goto bad_fork_free;
 	}
+#endif
+
+        /* BProc: (SLAVE) have the front end do the same fork.  This
+         * will assign us a masq pid as well as checking to make sure
+         * that the fork doesn't violate any limits set there. */
+        retval = bproc_hook_imv(p->pid, copy_process, (p, clone_flags));
+        if (retval < 0)
+                goto bad_fork_free;
 
 	atomic_inc(&p->user->__count);
 	atomic_inc(&p->user->processes);
@@ -970,7 +996,7 @@
 	p->pid = pid;
 	retval = -EFAULT;
 	if (clone_flags & CLONE_PARENT_SETTID)
-		if (put_user(p->pid, parent_tidptr))
+		if (put_user(bproc_hook_imv(p->pid, masq_pid,(p)), parent_tidptr))
 			goto bad_fork_cleanup;
 
 	p->proc_dentry = NULL;
@@ -1135,10 +1161,15 @@
 	}
 
 	nr_threads++;
+
+	/* BProc: (SLAVE) add the new process to our lists. */
+	bproc_hook(copy_process_2, (p));
 	write_unlock_irq(&tasklist_lock);
 	retval = 0;
 
 fork_out:
+	/* BProc: ALL clear the kernel call flag. */
+	bproc_clear_kcall();
 	if (retval)
 		return ERR_PTR(retval);
 	return p;
@@ -1175,6 +1206,8 @@
 	put_group_info(p->group_info);
 	atomic_dec(&p->user->processes);
 	free_uid(p->user);
+
+	bproc_hook_im(copy_process_cleanup,(p));
 bad_fork_free:
 	free_task(p);
 	goto fork_out;
@@ -1253,6 +1286,11 @@
 			init_completion(&vfork);
 		}
 
+		/* BProc: map process ID */
+		pid = bproc_hook_imv(pid, do_fork, (p));
+		/* BProc: we do kernel_thread with arbitrary user
+		 * flags.  E.g. CLONE_PTRACE or CLONE_STOPPED.
+		 */
 		if ((p->ptrace & PT_PTRACED) || (clone_flags & CLONE_STOPPED)) {
 			/*
 			 * We'll start up with an immediate SIGSTOP.
@@ -1283,6 +1321,7 @@
 	}
 	return pid;
 }
+EXPORT_SYMBOL_GPL(do_fork);
 
 /* SLAB cache for signal_struct structures (tsk->signal) */
 kmem_cache_t *signal_cachep;
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/kmod.c linux-2.6.9/kernel/kmod.c
--- linux-2.6.9-clean/kernel/kmod.c	2004-10-18 15:53:45.000000000 -0600
+++ linux-2.6.9/kernel/kmod.c	2004-10-27 13:58:35.000000000 -0600
@@ -36,6 +36,7 @@
 #include <linux/mount.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/bproc.h>
 #include <asm/uaccess.h>
 
 extern int max_threads;
@@ -203,6 +204,7 @@
 		 *
 		 * Thus the __user pointer cast is valid here.
 		 */
+		bproc_kcall();
 		sys_wait4(pid, (int __user *) &sub_info->retval, 0, NULL);
 	}
 
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/Makefile linux-2.6.9/kernel/Makefile
--- linux-2.6.9-clean/kernel/Makefile	2004-10-18 15:53:43.000000000 -0600
+++ linux-2.6.9/kernel/Makefile	2004-10-27 13:58:35.000000000 -0600
@@ -7,7 +7,7 @@
 	    sysctl.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o workqueue.o pid.o \
 	    rcupdate.o intermodule.o extable.o params.o posix-timers.o \
-	    kthread.o
+	    kthread.o bproc_hook.o
 
 obj-$(CONFIG_FUTEX) += futex.o
 obj-$(CONFIG_GENERIC_ISA_DMA) += dma.o
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/pid.c linux-2.6.9/kernel/pid.c
--- linux-2.6.9-clean/kernel/pid.c	2004-10-18 15:54:32.000000000 -0600
+++ linux-2.6.9/kernel/pid.c	2004-10-27 13:58:35.000000000 -0600
@@ -145,6 +145,7 @@
 failure:
 	return -1;
 }
+EXPORT_SYMBOL_GPL(alloc_pidmap);
 
 struct pid * fastcall find_pid(enum pid_type type, int nr)
 {
@@ -177,6 +178,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(attach_pid);
 
 static inline int __detach_pid(task_t *task, enum pid_type type)
 {
@@ -214,6 +216,7 @@
 			return;
 	free_pidmap(nr);
 }
+EXPORT_SYMBOL_GPL(detach_pid);
 
 task_t *find_task_by_pid_type(int type, int nr)
 {
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/#ptrace.c# linux-2.6.9/kernel/#ptrace.c#
--- linux-2.6.9-clean/kernel/#ptrace.c#	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.9/kernel/#ptrace.c#	2004-10-27 13:58:35.000000000 -0600
@@ -0,0 +1,408 @@
+/*
+ * linux/kernel/ptrace.c
+ *
+ * (C) Copyright 1999 Linus Torvalds
+ *
+ * Common interfaces for "ptrace()" which we do not want
+ * to continually duplicate across every architecture.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+#include <linux/ptrace.h>
+#include <linux/security.h>
+#include <linux/bproc.h>
+
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+/*
+ * ptrace a task: make the debugger its new parent and
+ * move it to the ptrace list.
+ *
+ * Must be called with the tasklist lock write-held.
+ */
+void __ptrace_link(task_t *child, task_t *new_parent)
+{
+	if (!list_empty(&child->ptrace_list))
+		BUG();
+	if (child->parent == new_parent)
+		return;
+	list_add(&child->ptrace_list, &child->parent->ptrace_children);
+	REMOVE_LINKS(child);
+	child->parent = new_parent;
+	SET_LINKS(child);
+}
+EXPORT_SYMBOL_GPL(__ptrace_link);
+ 
+/*
+ * unptrace a task: move it back to its original parent and
+ * remove it from the ptrace list.
+ *
+ * Must be called with the tasklist lock write-held.
+ */
+void __ptrace_unlink(task_t *child)
+{
+	if (!child->ptrace)
+		BUG();
+	child->ptrace = 0;
+	if (list_empty(&child->ptrace_list))
+		return;
+	list_del_init(&child->ptrace_list);
+	REMOVE_LINKS(child);
+	child->parent = child->real_parent;
+	SET_LINKS(child);
+
+	if (child->state == TASK_TRACED) {
+		/*
+		 * Turn a tracing stop into a normal stop now,
+		 * since with no tracer there would be no way
+		 * to wake it up with SIGCONT or SIGKILL.
+		 */
+		child->state = TASK_STOPPED;
+	}
+}
+EXPORT_SYMBOL_GPL(__ptrace_unlink);
+
+/*
+ * Check that we have indeed attached to the thing..
+ */
+int ptrace_check_attach(struct task_struct *child, int kill)
+{
+	int ret = -ESRCH;
+
+	/*
+	 * We take the read lock around doing both checks to close a
+	 * possible race where someone else was tracing our child and
+	 * detached between these two checks.  After this locked check,
+	 * we are sure that this is our traced child and that can only
+	 * be changed by us so it's not changing right after this.
+	 */
+	read_lock(&tasklist_lock);
+	if ((child->ptrace & PT_PTRACED) &&
+	    (child->parent == current ||
+	     bproc_hook_v(0, ptrace_check_attach, (child))) &&
+	    child->signal != NULL) {
+		ret = 0;
+		if (bproc_isghost(child)) {
+			read_unlock(&tasklist_lock);
+			return 0;
+		}
+		spin_lock_irq(&child->sighand->siglock);
+		if (child->state == TASK_STOPPED) {
+			child->state = TASK_TRACED;
+		} else if (child->state != TASK_TRACED && !kill) {
+			ret = -ESRCH;
+		}
+		spin_unlock_irq(&child->sighand->siglock);
+	}
+	read_unlock(&tasklist_lock);
+
+	if (!ret && !kill) {
+	
+
+
+	wait_task_inactive(child);
+	}
+
+	/* All systems go.. */
+	return ret;
+}
+
+int ptrace_attach(struct task_struct *task)
+{
+	int retval;
+
+#ifdef CONFIG_BPROC
+	/* BProc: ptrace attach isn't atomic.  This is a problem
+	 * because a process can 'depart' during the first part of the
+	 * ptrace attach.  That's because a departing process does
+	 * it's work under write_lock_irq on the tasklist_lock.  Part
+	 * of that work is reading the ptrace flags.
+	 */
+	spin_lock(&bproc_ptrace_attach_lock);
+
+	read_lock(&tasklist_lock); /* protects task->bproc.* */
+	/* BProc: check to make sure the target hasn't slipped out
+	 * from under us. */
+	if (current->bproc.context && !bproc_ismasq(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		return -ESRCH;
+	}
+	/* This might have to be done as remote call:
+	 *   -  If the target is a ghost
+	 *   -  If the target is has left between task lookup and now.
+	 */
+
+	/* Target is a ghost process */
+	if (bproc_isghost(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		return bproc_hook_v(-ESRCH, ptrace_ghost,
+				    (PTRACE_ATTACH, task->pid, 0, 0));
+	}
+
+	/* Target slipped out from under us - do a remote request */
+	if (bproc_ismasq(current) && !bproc_ismasq(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		/* current->bproc.arg contains the last pid we did a
+		 * lookup on */
+		return bproc_hook_v(-ESRCH, ptrace_no_proc,
+				    (PTRACE_ATTACH, current->bproc.arg, 0, 0));
+	}
+	read_unlock(&tasklist_lock);
+#endif
+
+	task_lock(task);
+	retval = -EPERM;
+	if (task->pid <= 1)
+		goto bad;
+	if (task == current)
+		goto bad;
+	if (!task->mm)
+		goto bad;
+	if(((current->uid != task->euid) ||
+	    (current->uid != task->suid) ||
+	    (current->uid != task->uid) ||
+ 	    (current->gid != task->egid) ||
+ 	    (current->gid != task->sgid) ||
+ 	    (current->gid != task->gid)) && !capable(CAP_SYS_PTRACE))
+		goto bad;
+	rmb();
+	if (!task->mm->dumpable && !capable(CAP_SYS_PTRACE))
+		goto bad;
+	/* the same process cannot be attached many times */
+	if (task->ptrace & PT_PTRACED)
+		goto bad;
+	retval = security_ptrace(current, task);
+	if (retval)
+		goto bad;
+
+	/* Go */
+	task->ptrace |= PT_PTRACED;
+	if (capable(CAP_SYS_PTRACE))
+		task->ptrace |= PT_PTRACE_CAP;
+	task_unlock(task);
+
+	write_lock_irq(&tasklist_lock);
+	__ptrace_link(task, bproc_hook_v(current, ptrace_attach, (task)));
+	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_BPROC
+	spin_unlock(&bproc_ptrace_attach_lock);
+#endif
+
+	force_sig_specific(SIGSTOP, task);
+	return 0;
+
+bad:
+	task_unlock(task);
+#ifdef CONFIG_BPROC
+	spin_unlock(&bproc_ptrace_attach_lock);
+#endif
+	return retval;
+}
+
+int ptrace_detach(struct task_struct *child, unsigned int data)
+{
+	if ((unsigned long) data > _NSIG)
+		return	-EIO;
+
+	/* Architecture-specific hardware disable .. */
+	ptrace_disable(child);
+
+	/* .. re-parent .. */
+	child->exit_code = data;
+
+	write_lock_irq(&tasklist_lock);
+	bproc_hook(ptrace_detach,(child));
+	__ptrace_unlink(child);
+	/* .. and wake it up. */
+	if (child->state != TASK_ZOMBIE)
+		wake_up_process(child);
+	write_unlock_irq(&tasklist_lock);
+
+	return 0;
+}
+
+/*
+ * Access another process' address space.
+ * Source/target buffer must be kernel space, 
+ * Do not walk the page table directly, use get_user_pages
+ */
+
+int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write)
+{
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	struct page *page;
+	void *old_buf = buf;
+
+	mm = get_task_mm(tsk);
+	if (!mm)
+		return 0;
+
+	down_read(&mm->mmap_sem);
+	/* ignore errors, just check how much was sucessfully transfered */
+	while (len) {
+		int bytes, ret, offset;
+		void *maddr;
+
+		ret = get_user_pages(tsk, mm, addr, 1,
+				write, 1, &page, &vma);
+		if (ret <= 0)
+			break;
+
+		bytes = len;
+		offset = addr & (PAGE_SIZE-1);
+		if (bytes > PAGE_SIZE-offset)
+			bytes = PAGE_SIZE-offset;
+
+		maddr = kmap(page);
+		if (write) {
+			copy_to_user_page(vma, page, addr,
+					  maddr + offset, buf, bytes);
+			set_page_dirty_lock(page);
+		} else {
+			copy_from_user_page(vma, page, addr,
+					    buf, maddr + offset, bytes);
+		}
+		kunmap(page);
+		page_cache_release(page);
+		len -= bytes;
+		buf += bytes;
+		addr += bytes;
+	}
+	up_read(&mm->mmap_sem);
+	mmput(mm);
+	
+	return buf - old_buf;
+}
+
+int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)
+{
+	int copied = 0;
+
+	while (len > 0) {
+		char buf[128];
+		int this_len, retval;
+
+		this_len = (len > sizeof(buf)) ? sizeof(buf) : len;
+		retval = access_process_vm(tsk, src, buf, this_len, 0);
+		if (!retval) {
+			if (copied)
+				break;
+			return -EIO;
+		}
+		if (copy_to_user(dst, buf, retval))
+			return -EFAULT;
+		copied += retval;
+		src += retval;
+		dst += retval;
+		len -= retval;			
+	}
+	return copied;
+}
+
+int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)
+{
+	int copied = 0;
+
+	while (len > 0) {
+		char buf[128];
+		int this_len, retval;
+
+		this_len = (len > sizeof(buf)) ? sizeof(buf) : len;
+		if (copy_from_user(buf, src, this_len))
+			return -EFAULT;
+		retval = access_process_vm(tsk, dst, buf, this_len, 1);
+		if (!retval) {
+			if (copied)
+				break;
+			return -EIO;
+		}
+		copied += retval;
+		src += retval;
+		dst += retval;
+		len -= retval;			
+	}
+	return copied;
+}
+
+static int ptrace_setoptions(struct task_struct *child, long data)
+{
+	child->ptrace &= ~PT_TRACE_MASK;
+
+	if (data & PTRACE_O_TRACESYSGOOD)
+		child->ptrace |= PT_TRACESYSGOOD;
+
+	if (data & PTRACE_O_TRACEFORK)
+		child->ptrace |= PT_TRACE_FORK;
+
+	if (data & PTRACE_O_TRACEVFORK)
+		child->ptrace |= PT_TRACE_VFORK;
+
+	if (data & PTRACE_O_TRACECLONE)
+		child->ptrace |= PT_TRACE_CLONE;
+
+	if (data & PTRACE_O_TRACEEXEC)
+		child->ptrace |= PT_TRACE_EXEC;
+
+	if (data & PTRACE_O_TRACEVFORKDONE)
+		child->ptrace |= PT_TRACE_VFORK_DONE;
+
+	if (data & PTRACE_O_TRACEEXIT)
+		child->ptrace |= PT_TRACE_EXIT;
+
+	return (data & ~PTRACE_O_MASK) ? -EINVAL : 0;
+}
+
+static int ptrace_getsiginfo(struct task_struct *child, siginfo_t __user * data)
+{
+	if (child->last_siginfo == NULL)
+		return -EINVAL;
+	return copy_siginfo_to_user(data, child->last_siginfo);
+}
+
+static int ptrace_setsiginfo(struct task_struct *child, siginfo_t __user * data)
+{
+	if (child->last_siginfo == NULL)
+		return -EINVAL;
+	if (copy_from_user(child->last_siginfo, data, sizeof (siginfo_t)) != 0)
+		return -EFAULT;
+	return 0;
+}
+
+int ptrace_request(struct task_struct *child, long request,
+		   long addr, long data)
+{
+	int ret = -EIO;
+
+	switch (request) {
+#ifdef PTRACE_OLDSETOPTIONS
+	case PTRACE_OLDSETOPTIONS:
+#endif
+	case PTRACE_SETOPTIONS:
+		ret = ptrace_setoptions(child, data);
+		break;
+	case PTRACE_GETEVENTMSG:
+		ret = put_user(child->ptrace_message, (unsigned long __user *) data);
+		break;
+	case PTRACE_GETSIGINFO:
+		ret = ptrace_getsiginfo(child, (siginfo_t __user *) data);
+		break;
+	case PTRACE_SETSIGINFO:
+		ret = ptrace_setsiginfo(child, (siginfo_t __user *) data);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/ptrace.c linux-2.6.9/kernel/ptrace.c
--- linux-2.6.9-clean/kernel/ptrace.c	2004-10-18 15:55:36.000000000 -0600
+++ linux-2.6.9/kernel/ptrace.c	2004-10-27 13:58:35.000000000 -0600
@@ -16,6 +16,7 @@
 #include <linux/smp_lock.h>
 #include <linux/ptrace.h>
 #include <linux/security.h>
+#include <linux/bproc.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -37,6 +38,7 @@
 	child->parent = new_parent;
 	SET_LINKS(child);
 }
+EXPORT_SYMBOL_GPL(__ptrace_link);
  
 /*
  * unptrace a task: move it back to its original parent and
@@ -65,6 +67,7 @@
 		child->state = TASK_STOPPED;
 	}
 }
+EXPORT_SYMBOL_GPL(__ptrace_unlink);
 
 /*
  * Check that we have indeed attached to the thing..
@@ -81,9 +84,15 @@
 	 * be changed by us so it's not changing right after this.
 	 */
 	read_lock(&tasklist_lock);
-	if ((child->ptrace & PT_PTRACED) && child->parent == current &&
+	if ((child->ptrace & PT_PTRACED) &&
+	    (child->parent == current ||
+	     bproc_hook_v(0, ptrace_check_attach, (child))) &&
 	    child->signal != NULL) {
 		ret = 0;
+		if (bproc_isghost(child)) {
+			read_unlock(&tasklist_lock);
+			return 0;
+		}
 		spin_lock_irq(&child->sighand->siglock);
 		if (child->state == TASK_STOPPED) {
 			child->state = TASK_TRACED;
@@ -105,6 +114,49 @@
 int ptrace_attach(struct task_struct *task)
 {
 	int retval;
+
+#ifdef CONFIG_BPROC
+	/* BProc: ptrace attach isn't atomic.  This is a problem
+	 * because a process can 'depart' during the first part of the
+	 * ptrace attach.  That's because a departing process does
+	 * it's work under write_lock_irq on the tasklist_lock.  Part
+	 * of that work is reading the ptrace flags.
+	 */
+	spin_lock(&bproc_ptrace_attach_lock);
+
+	read_lock(&tasklist_lock); /* protects task->bproc.* */
+	/* BProc: check to make sure the target hasn't slipped out
+	 * from under us. */
+	if (current->bproc.context && !bproc_ismasq(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		return -ESRCH;
+	}
+	/* This might have to be done as remote call:
+	 *   -  If the target is a ghost
+	 *   -  If the target is has left between task lookup and now.
+	 */
+
+	/* Target is a ghost process */
+	if (bproc_isghost(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		return bproc_hook_v(-ESRCH, ptrace_ghost,
+				    (PTRACE_ATTACH, task->pid, 0, 0));
+	}
+
+	/* Target slipped out from under us - do a remote request */
+	if (bproc_ismasq(current) && !bproc_ismasq(task)) {
+		read_unlock(&tasklist_lock);
+		spin_unlock(&bproc_ptrace_attach_lock);
+		/* current->bproc.arg contains the last pid we did a
+		 * lookup on */
+		return bproc_hook_v(-ESRCH, ptrace_no_proc,
+				    (PTRACE_ATTACH, current->bproc.arg, 0, 0));
+	}
+	read_unlock(&tasklist_lock);
+#endif
+
 	task_lock(task);
 	retval = -EPERM;
 	if (task->pid <= 1)
@@ -137,14 +189,20 @@
 	task_unlock(task);
 
 	write_lock_irq(&tasklist_lock);
-	__ptrace_link(task, current);
+	__ptrace_link(task, bproc_hook_v(current, ptrace_attach, (task)));
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_BPROC
+	spin_unlock(&bproc_ptrace_attach_lock);
+#endif
 
 	force_sig_specific(SIGSTOP, task);
 	return 0;
 
 bad:
 	task_unlock(task);
+#ifdef CONFIG_BPROC
+	spin_unlock(&bproc_ptrace_attach_lock);
+#endif
 	return retval;
 }
 
@@ -160,6 +218,7 @@
 	child->exit_code = data;
 
 	write_lock_irq(&tasklist_lock);
+	bproc_hook(ptrace_detach,(child));
 	__ptrace_unlink(child);
 	/* .. and wake it up. */
 	if (child->state != TASK_ZOMBIE)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/sched.c linux-2.6.9/kernel/sched.c
--- linux-2.6.9-clean/kernel/sched.c	2004-10-18 15:54:55.000000000 -0600
+++ linux-2.6.9/kernel/sched.c	2004-10-27 13:58:35.000000000 -0600
@@ -43,6 +43,7 @@
 #include <linux/kthread.h>
 #include <linux/seq_file.h>
 #include <linux/times.h>
+#include <linux/bproc.h>
 #include <asm/tlb.h>
 
 #include <asm/unistd.h>
@@ -1498,7 +1499,7 @@
 	finish_task_switch(prev);
 
 	if (current->set_child_tid)
-		put_user(current->pid, current->set_child_tid);
+		put_user(bproc_hook_imv(current->pid, masq_pid,(current)), current->set_child_tid);
 }
 
 /*
@@ -2649,6 +2650,8 @@
 
 need_resched:
 	preempt_disable();
+	bproc_hook_im(schedule_in,());
+
 	prev = current;
 	rq = this_rq();
 
@@ -2786,6 +2789,8 @@
 	preempt_enable_no_resched();
 	if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
 		goto need_resched;
+
+	bproc_hook_im(schedule_out,());
 }
 
 EXPORT_SYMBOL(schedule);
@@ -3162,7 +3167,7 @@
  */
 static inline task_t *find_process_by_pid(pid_t pid)
 {
-	return pid ? find_task_by_pid(pid) : current;
+	return pid ? bproc_hook_imv(find_task_by_pid(pid),find_task,(pid)) : current;
 }
 
 /* Actually do priority change: must hold rq lock. */
@@ -3286,6 +3291,7 @@
 {
 	return setscheduler(pid, policy, param);
 }
+EXPORT_SYMBOL_GPL(sys_sched_setscheduler);
 
 /**
  * sys_sched_setparam - set/change the RT priority of a thread
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/signal.c linux-2.6.9/kernel/signal.c
--- linux-2.6.9-clean/kernel/signal.c	2004-10-18 15:53:51.000000000 -0600
+++ linux-2.6.9/kernel/signal.c	2004-10-27 13:58:35.000000000 -0600
@@ -21,6 +21,8 @@
 #include <linux/binfmts.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/interrupt.h>
+#include <linux/bproc.h>
 #include <asm/param.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -175,6 +177,12 @@
 	if (sigismember(&t->blocked, sig))
 		return 0;
 
+	/*
+	 * BProc: ghosts want anything that's not blocked.
+	 */
+	if (bproc_isghost(t))
+		return 0;
+
 	/* Is it explicitly or implicitly ignored? */
 	handler = t->sighand->action[sig-1].sa.sa_handler;
 	return   handler == SIG_IGN ||
@@ -887,6 +895,7 @@
 	specific_send_sig_info(sig, (void *)2, t);
 	spin_unlock_irqrestore(&t->sighand->siglock, flags);
 }
+EXPORT_SYMBOL_GPL(force_sig_specific);
 
 /*
  * Test if P wants to take SIG.  After we've checked all threads with this,
@@ -1106,6 +1115,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(group_send_sig_info);
 
 /*
  * kill_pg_info() sends a signal to a process group: this is what the tty
@@ -1129,12 +1139,16 @@
 	} while_each_task_pid(pgrp, PIDTYPE_PGID, p);
 	return success ? 0 : retval;
 }
+EXPORT_SYMBOL_GPL(__kill_pg_info);
 
 int
 kill_pg_info(int sig, struct siginfo *info, pid_t pgrp)
 {
 	int retval;
 
+	if (!in_interrupt())
+		bproc_hook_imr(kill_pg_info, (sig, info, pgrp));
+
 	read_lock(&tasklist_lock);
 	retval = __kill_pg_info(sig, info, pgrp);
 	read_unlock(&tasklist_lock);
@@ -1178,6 +1192,9 @@
 	int error;
 	struct task_struct *p;
 
+	if (!in_interrupt())
+		bproc_hook_imr(kill_proc_info,(sig, info, pid));
+
 	read_lock(&tasklist_lock);
 	p = find_task_by_pid(pid);
 	error = -ESRCH;
@@ -1195,7 +1212,7 @@
  * is probably wrong.  Should make it like BSD or SYSV.
  */
 
-static int kill_something_info(int sig, struct siginfo *info, int pid)
+int kill_something_info(int sig, struct siginfo *info, int pid)
 {
 	if (!pid) {
 		return kill_pg_info(sig, info, process_group(current));
@@ -1220,6 +1237,7 @@
 		return kill_proc_info(sig, info, pid);
 	}
 }
+EXPORT_SYMBOL_GPL(kill_something_info);
 
 /*
  * These are for backward compatibility with the rest of the kernel source.
@@ -1487,7 +1505,7 @@
 		BUG();
 
  	/* do_notify_parent_cldstop should have been called instead.  */
- 	BUG_ON(tsk->state & (TASK_STOPPED|TASK_TRACED));
+ 	BUG_ON(bproc_hook_v(tsk->state,task_state,(tsk)) & (TASK_STOPPED|TASK_TRACED));
 
 	BUG_ON(!tsk->ptrace &&
 	       (tsk->group_leader != tsk || !thread_group_empty(tsk)));
@@ -1540,6 +1558,7 @@
 	__wake_up_parent(tsk, tsk->parent);
 	spin_unlock_irqrestore(&psig->siglock, flags);
 }
+EXPORT_SYMBOL_GPL(do_notify_parent);
 
 static void
 do_notify_parent_cldstop(struct task_struct *tsk, struct task_struct *parent,
@@ -1584,6 +1603,7 @@
 	__wake_up_parent(tsk, parent);
 	spin_unlock_irqrestore(&sighand->siglock, flags);
 }
+EXPORT_SYMBOL_GPL(do_notify_parent_cldstop);
 
 /*
  * This must be called with current->sighand->siglock held.
@@ -1593,7 +1613,7 @@
  * That makes it a way to test a stopped process for
  * being ptrace-stopped vs being job-control-stopped.
  */
-static void ptrace_stop(int exit_code, siginfo_t *info)
+void ptrace_stop(int exit_code, siginfo_t *info)
 {
 	BUG_ON(!(current->ptrace & PT_PTRACED));
 
@@ -1629,6 +1649,7 @@
 	 */
 	recalc_sigpending();
 }
+EXPORT_SYMBOL_GPL(ptrace_stop);
 
 void ptrace_notify(int exit_code)
 {
@@ -2271,7 +2292,7 @@
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
-	info.si_pid = current->tgid;
+	info.si_pid = bproc_hook_imv(current->tgid,masq_tgid,(current));
 	info.si_uid = current->uid;
 
 	return kill_something_info(sig, &info, pid);
@@ -2300,13 +2321,13 @@
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_TKILL;
-	info.si_pid = current->tgid;
+	info.si_pid = bproc_hook_imv(current->tgid,masq_tgid,(current));
 	info.si_uid = current->uid;
 
 	read_lock(&tasklist_lock);
-	p = find_task_by_pid(pid);
+	p = bproc_hook_imv(find_task_by_pid(pid),find_task,(pid));
 	error = -ESRCH;
-	if (p && (p->tgid == tgid)) {
+	if (p && (bproc_hook_imv(p->tgid,masq_tgid,(p)) == tgid)) {
 		error = check_kill_permission(sig, &info, p);
 		/*
 		 * The null signal is a permissions and process existence
@@ -2340,11 +2361,11 @@
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_TKILL;
-	info.si_pid = current->tgid;
+	info.si_pid = bproc_hook_imv(current->tgid,masq_tgid,(current));
 	info.si_uid = current->uid;
 
 	read_lock(&tasklist_lock);
-	p = find_task_by_pid(pid);
+	p = bproc_hook_imv(find_task_by_pid(pid),find_task,(pid));
 	error = -ESRCH;
 	if (p) {
 		error = check_kill_permission(sig, &info, p);
@@ -2451,6 +2472,7 @@
 	spin_unlock_irq(&current->sighand->siglock);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(do_sigaction);
 
 int 
 do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/sys.c linux-2.6.9/kernel/sys.c
--- linux-2.6.9-clean/kernel/sys.c	2004-10-18 15:53:13.000000000 -0600
+++ linux-2.6.9/kernel/sys.c	2004-10-27 13:58:35.000000000 -0600
@@ -23,6 +23,7 @@
 #include <linux/security.h>
 #include <linux/dcookies.h>
 #include <linux/suspend.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -600,6 +601,7 @@
 	current->fsgid = new_egid;
 	current->egid = new_egid;
 	current->gid = new_rgid;
+	bproc_hook_im(set_creds, ());
 	return 0;
 }
 
@@ -637,6 +639,7 @@
 	}
 	else
 		return -EPERM;
+	bproc_hook_im(set_creds, ());
 	return 0;
 }
   
@@ -663,6 +666,7 @@
 		wmb();
 	}
 	current->uid = new_ruid;
+	bproc_hook_im(set_creds, ());
 	return 0;
 }
 
@@ -725,7 +729,10 @@
 		current->suid = current->euid;
 	current->fsuid = current->euid;
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
+	retval = security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
+	if (retval == 0)
+		bproc_hook_im(set_creds, ());
+	return retval;
 }
 
 
@@ -770,7 +777,10 @@
 	current->fsuid = current->euid = uid;
 	current->suid = new_suid;
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
+	retval = security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
+	if (retval == 0)
+		bproc_hook_im(set_creds, ());
+	return retval;
 }
 
 
@@ -816,7 +826,10 @@
 	if (suid != (uid_t) -1)
 		current->suid = suid;
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
+	retval = security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
+	if (retval == 0)
+		bproc_hook_im(set_creds, ());
+	return retval;
 }
 
 asmlinkage long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid)
@@ -907,7 +920,7 @@
 	}
 
 	security_task_post_setuid(old_fsuid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS);
-
+	bproc_hook_im(set_creds, ());
 	return old_fsuid;
 }
 
@@ -933,6 +946,7 @@
 		}
 		current->fsgid = gid;
 	}
+	bproc_hook_im(set_creds, ());
 	return old_fsgid;
 }
 
@@ -1003,6 +1017,9 @@
 	struct task_struct *p;
 	int err = -EINVAL;
 
+	if (bproc_ismasq(current))
+		return bproc_hook_v(0, sys_setpgid_m, (pid, pgid));
+
 	if (!pid)
 		pid = current->pid;
 	if (!pgid)
@@ -1060,6 +1077,8 @@
 		detach_pid(p, PIDTYPE_PGID);
 		p->signal->pgrp = pgid;
 		attach_pid(p, PIDTYPE_PGID, pgid);
+		if (bproc_isghost(p))
+			bproc_hook(sys_setpgid_g, (p));
 	}
 
 	err = 0;
@@ -1068,9 +1087,11 @@
 	write_unlock_irq(&tasklist_lock);
 	return err;
 }
+EXPORT_SYMBOL_GPL(sys_setpgid);
 
 asmlinkage long sys_getpgid(pid_t pid)
 {
+	bproc_hook_imr(sys_getpgid,(pid));
 	if (!pid) {
 		return process_group(current);
 	} else {
@@ -1090,19 +1111,21 @@
 		return retval;
 	}
 }
+EXPORT_SYMBOL_GPL(sys_getpgid);
 
 #ifdef __ARCH_WANT_SYS_GETPGRP
 
 asmlinkage long sys_getpgrp(void)
 {
 	/* SMP - assuming writes are word atomic this is fine */
-	return process_group(current);
+	return bproc_hook_imv(process_group(current),sys_getpgid,(0));
 }
 
 #endif
 
 asmlinkage long sys_getsid(pid_t pid)
 {
+	bproc_hook_imr(sys_getsid,(pid));
 	if (!pid) {
 		return current->signal->session;
 	} else {
@@ -1122,6 +1145,7 @@
 		return retval;
 	}
 }
+EXPORT_SYMBOL_GPL(sys_getsid);
 
 asmlinkage long sys_setsid(void)
 {
@@ -1131,6 +1155,8 @@
 	if (!thread_group_leader(current))
 		return -EINVAL;
 
+	bproc_hook_imr(sys_setsid,());
+
 	write_lock_irq(&tasklist_lock);
 
 	pid = find_pid(PIDTYPE_PGID, current->pid);
@@ -1146,6 +1172,7 @@
 	write_unlock_irq(&tasklist_lock);
 	return err;
 }
+EXPORT_SYMBOL_GPL(sys_setsid);
 
 /*
  * Supplementary group IDs
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/timer.c linux-2.6.9/kernel/timer.c
--- linux-2.6.9-clean/kernel/timer.c	2004-10-18 15:54:55.000000000 -0600
+++ linux-2.6.9/kernel/timer.c	2004-10-27 13:58:35.000000000 -0600
@@ -31,6 +31,7 @@
 #include <linux/time.h>
 #include <linux/jiffies.h>
 #include <linux/cpu.h>
+#include <linux/bproc.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -561,6 +562,7 @@
 struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
 
 EXPORT_SYMBOL(xtime);
+EXPORT_SYMBOL_GPL(wall_to_monotonic);
 
 /* Don't completely fail for HZ > 500.  */
 int tickadj = 500/HZ ? : 1;		/* microsecs */
@@ -1009,7 +1011,7 @@
  */
 asmlinkage long sys_getpid(void)
 {
-	return current->tgid;
+	return bproc_hook_imv(current->tgid, masq_tgid, (current));
 }
 
 /*
@@ -1036,7 +1038,7 @@
 
 	parent = me->group_leader->real_parent;
 	for (;;) {
-		pid = parent->tgid;
+		pid = bproc_hook_imv(parent->tgid,sys_getppid,(parent));;
 #ifdef CONFIG_SMP
 {
 		struct task_struct *old = parent;
@@ -1170,7 +1172,7 @@
 /* Thread ID - the internal kernel "pid" */
 asmlinkage long sys_gettid(void)
 {
-	return current->pid;
+	return bproc_hook_imv(current->pid, masq_pid, (current));
 }
 
 static long __sched nanosleep_restart(struct restart_block *restart)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/kernel/user.c linux-2.6.9/kernel/user.c
--- linux-2.6.9-clean/kernel/user.c	2004-10-18 15:53:50.000000000 -0600
+++ linux-2.6.9/kernel/user.c	2004-10-27 13:58:35.000000000 -0600
@@ -12,6 +12,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/bitops.h>
+#include <linux/module.h>
 
 /*
  * UID task count cache, to get fast user lookup in "alloc_uid"
@@ -133,6 +134,7 @@
 	}
 	return up;
 }
+EXPORT_SYMBOL_GPL(alloc_uid);
 
 void switch_uid(struct user_struct *new_user)
 {
@@ -149,6 +151,7 @@
 	current->user = new_user;
 	free_uid(old_user);
 }
+EXPORT_SYMBOL_GPL(switch_uid);
 
 
 static int __init uid_cache_init(void)
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/mm/mmap.c linux-2.6.9/mm/mmap.c
--- linux-2.6.9-clean/mm/mmap.c	2004-10-18 15:54:37.000000000 -0600
+++ linux-2.6.9/mm/mmap.c	2004-10-27 13:58:35.000000000 -0600
@@ -1092,6 +1092,7 @@
 		addr = vma->vm_end;
 	}
 }
+EXPORT_SYMBOL_GPL(arch_get_unmapped_area);
 #endif	
 
 void arch_unmap_area(struct vm_area_struct *area)
@@ -1103,6 +1104,7 @@
 			area->vm_start < area->vm_mm->free_area_cache)
 		area->vm_mm->free_area_cache = area->vm_start;
 }
+EXPORT_SYMBOL_GPL(arch_unmap_area);
 
 /*
  * This mmap-allocator allocates new areas top-down from below the
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/mm/mprotect.c linux-2.6.9/mm/mprotect.c
--- linux-2.6.9-clean/mm/mprotect.c	2004-10-18 15:55:36.000000000 -0600
+++ linux-2.6.9/mm/mprotect.c	2004-10-27 13:58:35.000000000 -0600
@@ -8,6 +8,7 @@
  *  (C) Copyright 2002 Red Hat Inc, All Rights Reserved
  */
 
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/hugetlb.h>
 #include <linux/slab.h>
@@ -288,3 +289,4 @@
 	up_write(&current->mm->mmap_sem);
 	return error;
 }
+EXPORT_SYMBOL_GPL(sys_mprotect);
diff -urNX /home/hendriks/dontdiff linux-2.6.9-clean/net/socket.c linux-2.6.9/net/socket.c
--- linux-2.6.9-clean/net/socket.c	2004-10-18 15:53:50.000000000 -0600
+++ linux-2.6.9/net/socket.c	2004-10-27 13:58:35.000000000 -0600
@@ -120,7 +120,7 @@
  *	in the operation structures but are done directly via the socketcall() multiplexor.
  */
 
-static struct file_operations socket_file_ops = {
+struct file_operations socket_file_ops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
 	.aio_read =	sock_aio_read,
@@ -135,6 +135,7 @@
 	.writev =	sock_writev,
 	.sendpage =	sock_sendpage
 };
+EXPORT_SYMBOL_GPL(socket_file_ops);
 
 /*
  *	The protocol list. Each protocol is registered in here.
@@ -330,7 +331,8 @@
 	return get_sb_pseudo(fs_type, "socket:", &sockfs_ops, SOCKFS_MAGIC);
 }
 
-static struct vfsmount *sock_mnt;
+struct vfsmount *sock_mnt;
+EXPORT_SYMBOL_GPL(sock_mnt);
 
 static struct file_system_type sock_fs_type = {
 	.name =		"sockfs",
@@ -341,10 +343,12 @@
 {
 	return 1;
 }
-static struct dentry_operations sockfs_dentry_operations = {
+struct dentry_operations sockfs_dentry_operations = {
 	.d_delete =	sockfs_delete_dentry,
 };
 
+EXPORT_SYMBOL_GPL(sockfs_dentry_operations);
+
 /*
  *	Obtains the first available file descriptor and sets it up for use.
  *
